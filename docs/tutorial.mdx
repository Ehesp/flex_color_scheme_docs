# Tutorial

In this tutorial we go through all the bundled examples and explain the
used `FlexColorScheme` features in each example.

The key part for each example is always in the used `MaterialApp`, where all the
FlexColorScheme setup for the themes are made. The rest of the content in the
examples is mainly there to make a visual presentation of the resulting theme from
the used color scheme, and to allow you to control the theme settings.

## Example 1 - Basic Theme Usage

The first and simplest example shows how you can use a predefined color scheme
in `FlexColorScheme` to define light and dark themes using the selected scheme.
How to turn it into a theme used by your application, and then switch between
its light and dark mode themes. A theme showcase widget shows the theme's effect
on several common Material UI widgets.

> The full code is not shown below, only highlights.
> Please find the complete example code
> [here](https://github.com/rydmike/flex_color_scheme/tree/master/example/lib/example1).

 ```dart
void main() => runApp(const DemoApp());

class DemoApp extends StatefulWidget {
  const DemoApp({Key? key}) : super(key: key);

  @override
  _DemoAppState createState() => _DemoAppState();
}

class _DemoAppState extends State<DemoApp> {
  // Used to select if we use the dark or light theme, start with system mode.
  ThemeMode themeMode = ThemeMode.system;

  @override
  Widget build(BuildContext context) {
    // Select the predefined FlexScheme color scheme to use. Modify the
    // used FlexScheme enum value below to try other pre-made color schemes.
    const FlexScheme usedScheme = FlexScheme.mandyRed;

    return MaterialApp(
      debugShowCheckedModeBanner: false,
      scrollBehavior: AppScrollBehavior(),
      title: 'Basic Theme Usage',
      // Use a predefined FlexThemeData.light() theme for the light theme.
      theme: FlexThemeData.light(
        scheme: usedScheme,
        // Use very subtly themed app bar elevation in light mode.
        appBarElevation: 0.5,
      ),
      // Same definition for the dark theme, but using FlexThemeData.dark().
      darkTheme: FlexThemeData.dark(
        scheme: usedScheme,
        // Use stronger themed app bar elevation in dark mode.
        appBarElevation: 2,
      ),
      // Use the above dark or light theme based on active themeMode.
      themeMode: themeMode,
      home: HomePage(
        // We pass it the current theme mode.
        themeMode: themeMode,
        // On the home page we can toggle theme mode between light and dark.
        onThemeModeChanged: (ThemeMode mode) {
          setState(() {
            themeMode = mode;
          });
        },
        // Pass in the FlexSchemeData we used for the active theme.
        flexSchemeData: FlexColor.schemes[usedScheme]!,
      ),
    );
  }
}
```

To the `HomePage` we pass in the current value of the `themeMode` and use a
callback to get back its changed value, we use it to update
`themeMode` in a standard `setState` to make the app rebuild using
the new value.

We also pass in the `FlexSchemeData` we defined for our custom theme to the
`HomePage`. Not really needed, but we use it on the home page to show the
active theme's name, description and colors in a theme mode switch.

When you build and run **example 1** you get an application that looks
like this in light and dark mode:

[<img src="https://rydmike.com/assets_fcsv4/21-example-1-a-small.jpg?raw=true" alt="ColorScheme example 1 light"/>](https://rydmike.com/assets_fcsv4/21-example-1-a.png?raw=true)
[<img src="https://rydmike.com/assets_fcsv4/21-example-1-b-small.jpg?raw=true" alt="ColorScheme example 1 dark"/>](https://rydmike.com/assets_fcsv4/21-example-1-b.png?raw=true)
_Example 1) Using a built-in FlexColorScheme color scheme as application
theme. (click image to open hires version)_

Scroll down in the app to see the theme showcase further below. It presents the
theme with common Material UI widgets. You can try this example as a Flutter
[web app here](https://rydmike.com/flexcolorschemeV4Tut1).

## Example 2 - Custom Theme

This example shows how you can define your own color schemes using
`FlexSchemeColor` and `FlexSchemeData`, to create `FlexColorScheme` based
application themes from them.

> The full code is not shown below, only highlights.
> Please find the complete example code
> [here](https://github.com/rydmike/flex_color_scheme/tree/master/example/lib/example2).


In this example, and the ones after it, we use a `ThemeService` and
`ThemeController` to manage our theme settings. This follows the example
architecture you get when you create a Flutter template application
architecture with:

```bash
 > flutter create -t skeleton my_flutter_app
```

This example uses a theme service with only memory storage and no persistence.
In later examples we use locally persisting theme services. In this example we
use the theme controller to change the theme mode and to toggle opting in and
out of FlexColorScheme's opinionated sub-themes.

```dart
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  // This used theme service.
  final ThemeService themeService = ThemeServiceMem();
  // Initialize the theme service.
  await themeService.init();
  // Create a ThemeController that uses the ThemeService.
  final ThemeController themeController = ThemeController(themeService);
  // Load all the preferred theme settings, while the app is loading, before
  // MaterialApp is created. This prevents a sudden theme change when the app
  // is first displayed.
  await themeController.loadAll();
  // Run the app and pass in the ThemeController. The app listens to the
  // ThemeController for changes.
  runApp(DemoApp(themeController: themeController));
}
```

To make a custom color scheme, we for simplicity define it as a local
constant in this example. We make a `FlexSchemeData` object with a name,
description and `FlexSchemeColor` scheme colors defined for the light and
matching dark scheme.

```dart
const FlexSchemeData _myFlexScheme = FlexSchemeData(
  name: 'Midnight blue',
  description: 'Midnight blue theme, custom definition of all colors',
  light: FlexSchemeColor(
    primary: Color(0xFF00296B),
    primaryContainer: Color(0xFF2F5C91),
    secondary: Color(0xFFFF7B00),
    secondaryContainer: Color(0xFFFDB100),
  ),
  dark: FlexSchemeColor(
    primary: Color(0xFF6B8BC3),
    primaryContainer: Color(0xFF4874AA),
    secondary: Color(0xffff7155),
    secondaryContainer: Color(0xFFF1CB9D),
  ),
);
```

We could also have stored the light and dark scheme only in their own
`FlexSchemeColor` objects, and added them directly in their respective
`colors` property in `FlexThemeData.light` and `FlexThemeData.dark`.
However, we will also use this information on the `HomePage` for the
theme switch widget and to display the scheme name and description.
Putting them in a `FlexSchemeData` object that bundles the light and
dark scheme color `FlexSchemeColor`, plus a name and description, is a
convenient way to pass it along and re-use the information on the home page.

We use the `FlexSchemeData` instance `_myFlexScheme` instance `light` and `dark`
properties, as `colors` value for our `FlexThemeData.light` and
`FlexThemeData.dark`, that we then assign to the `MaterialApp` light theme
property `theme` and `darkTheme` property respectively.

The setup is similar to how we used one of the built-in predefined
`FlexSchemeData` objects in example 1 via its enum selection property,
but in this case we defined our own custom `FlexSchemeData` in `_myFlexScheme`
and used the `colors` property in `FlexSchemeData` to tell it to use those
colors instead of a built-in scheme.

We glue the `ThemeController` to the MaterialApp. The Flutter standard
`AnimatedBuilder` Widget listens to the `ThemeController` for changes.

The Flutter `AnimatedBuilder` is a bit oddly named for this use case. Here
it serves the purpose of functioning as a "`ChangeNotifierBuilder`",
that rebuilds its child when its `Listenable`, the `animation` changes.
Which it does whenever our `ThemeController` calls `notifyListeners`.
Which we do in the `ThemeController` class when we have new updated data
that requires the theme to update.

> The usage of the `AnimatedBuilder` does not have anything to do with the
> fact that the theme changes animate from current ThemeData and colors in it,
> to the new ones it changes to. This is a built-in feature in ThemeData and
> its inherited Theme in Flutter SDK. You can change the Theme with
> call-backs or other state management systems too, and still get the
> nice theme change animation.
>
> The `AnimatedBuilder` is a poor name when it is used as
> `ChangeNotifierBuilder`, that does not exist in Flutter SDK. It
> should, just for a better and more logical name, but the `AnimatedBuilder`
> serves the same purpose here as a `ChangeNotifierBuilder` would.

This results in that whenever you update any theme settings managed by
the `ThemeController`, the `MaterialApp` is rebuilt with the new setting
becoming effective. It rebuilds the entire app UI when any value in
the `ThemeController` trigger a change via a `notifyListeners` call.
This is fine though, since all property changes in it are of the
nature that the entire App UI needs to be redrawn anyway, so this approach
works well for this use case.

```dart
class DemoApp extends StatelessWidget {
  const DemoApp({Key? key, required this.themeController}) : super(key: key);
  final ThemeController themeController;

  @override
  Widget build(BuildContext context) {

    return AnimatedBuilder(
      animation: themeController,
      builder: (BuildContext context, Widget? child) {
        return MaterialApp(
          debugShowCheckedModeBanner: false,
          scrollBehavior: AppScrollBehavior(),
          title: 'Custom Theme',
          // Define FlexThemeData.light() theme using above custom colors.
          theme: FlexThemeData.light(
            colors: _myFlexScheme.light,
            // Opt in/out on FlexColorScheme sub-themes with theme controller.
            useSubThemes: themeController.useSubThemes,
            // Use  very low elevation light theme mode. On light colored
            // AppBars this show up as a nice thin underline effect.
            appBarElevation: 0.5,
            // Here we want the large default visual density on all platforms.
            visualDensity: VisualDensity.standard,
            // Use a custom font, Noto Sans in this case.
            fontFamily: GoogleFonts.notoSans().fontFamily,
          ),
          // Same setup for the dark theme, but using FlexThemeData.dark().
          darkTheme: FlexThemeData.dark(
            colors: _myFlexScheme.dark,
            useSubThemes: themeController.useSubThemes,
            appBarElevation: 1,
            visualDensity: VisualDensity.standard,
            fontFamily: GoogleFonts.notoSans().fontFamily,
          ),
          // Use the dark or light theme, based on theme controller setting.
          themeMode: themeController.themeMode,
          home: HomePage(
            flexSchemeData: _myFlexScheme,
            // Pass in the theme controller to the home page.
            controller: themeController,
          ),
        );
      });
  }
}
```

> As shown above, you can add a font via just a `fontFamily` from GoogleFonts.
For better and more fine controlled results, prefer defining complete
`TextThemes,` using a font and its different styles, you can then even use
more than one font for your text theme. Then assign the `TextTheme` to
the `textTheme` and `primaryTextTheme` properties in `FlexThemeData`.
This is how you would use do it with standard `ThemeData` too.

The `themeController` is also passed to the `HomePage` where we use it in UI
widgets to change the theme mode, and to opt in and out of using the sub themes
feature in FlexColorScheme.

When you build and run **example 2** you get a sample application that looks
like this in light and dark mode:
[<img src="https://rydmike.com/assets_fcsv4/22-example-2-a-small.jpg?raw=true" alt="ColorScheme example 2 light" />](https://rydmike.com/assets_fcsv4/22-example-2-a.png?raw=true)
[<img src="https://rydmike.com/assets_fcsv4/22-example-2-b-small.jpg?raw=true" alt="ColorScheme example 2 dark" />](https://rydmike.com/assets_fcsv4/22-example-2-b.png?raw=true)
_Example 2) Using custom colors with FlexColorScheme color scheme as
application theme (click image to open hires version)_

Scroll down in the app to see the theme showcase further below. It presents the
theme with common Material UI widgets. You can try this example as a Flutter
[web app here](https://rydmike.com/flexcolorschemeV4Tut2).


## Example 3 - Four Themes

This example shows how you can use three built-in color schemes, add a custom
scheme, using the same colors as in example 2. We use these four color schemes
as selectable `FlexColorScheme` based theme options. The example also uses surface
colors with primary color blends.

> The full code is not shown below, only highlights.
> Please find the complete example code
> [here](https://github.com/rydmike/flex_color_scheme/tree/master/example/lib/example3).

The `main` start function of the app is very similar to example 2, but in this
case we use another `ThemeService` implementation, the `ThemeServicePrefs`
version, that will locally persist the theme selection options we make.

The `ThemeServicePrefs` persistence is based on the popular package
[SharedPreferences](https://pub.dev/packages/shared_preferences).

```dart
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  // Here we can use Shared Preferences. The examples are all built using same
  // "example" app. If we use SharedPreferences in more than one of the apps
  // they would use the same storage container and share the settings when you
  // build them locally. By using Hive for most examples, we can change
  // the storage container name for each example. In these demos the
  // SharedPreferences service is only used for this example, but you can swap
  // in the Hive based one here as well if you want to try it.
  // This also demonstrates how swap used persistence implementation.
  final ThemeService themeService = ThemeServicePrefs();
  // To swap to Hive use this instead:
  // final ThemeService themeService = ThemeServiceHive('flex_scheme_box_3');
  // Initialize the theme service.
  await themeService.init();
  // Create a ThemeController that uses the ThemeService.
  final ThemeController themeController = ThemeController(themeService);
  // Load all the preferred theme settings, while the app is loading, before
  // MaterialApp is created. This prevents a sudden theme change when the app
  // is first displayed.
  await themeController.loadAll();
  // Run the app and pass in the ThemeController. The app listens to the
  // ThemeController for changes.
  runApp(DemoApp(themeController: themeController));
}
```

We set the surface mode to
`FlexSurfaceMode.levelSurfacesLowScaffold` and `blendLevel` to 20. This
gives us the same medium blend level primary color alpha blend, on the
theme colorscheme background and surface colors, while
scaffold uses a much lower blend.

In dark mode we decided to use the inverted blend surface mode to this,
`highScaffoldLowSurfaces`, where surface and background colors have lower
primary color alpha blend, in relation the Scaffold background color. We also
set the used blend level a btt lower, to 15 in dark mode.

 ```dart
 class DemoApp extends StatelessWidget {
  const DemoApp({Key? key, required this.themeController}) : super(key: key);
  final ThemeController themeController;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: themeController,
      builder: (BuildContext context, Widget? child) {
        return MaterialApp(
          debugShowCheckedModeBanner: false,
          scrollBehavior: AppScrollBehavior(),
          title: 'Four Themes',
          theme: FlexThemeData.light(
            colors: themeController.usedScheme == FlexScheme.custom
                    ? _myFlexScheme.light
                    : FlexColor.schemes[themeController.usedScheme]!.light,
            // We use a surface color mode where all Material surfaces use
            // the same primary color branding, but scaffold background
            // uses much less.
            surfaceMode: FlexSurfaceMode.levelSurfacesLowScaffold,
            // We set the blend level strength to 20.
            blendLevel: 20,
            appBarElevation: 0.5,
            useSubThemes: themeController.useSubThemes,
            visualDensity: FlexColorScheme.comfortablePlatformDensity,
            fontFamily: GoogleFonts.notoSans().fontFamily,
          ),
          // We do the exact same definition for the dark theme.
          darkTheme: FlexThemeData.dark(
            colors: themeController.usedScheme == FlexScheme.custom
                    ? _myFlexScheme.dark
                    : FlexColor.schemes[themeController.usedScheme]!.dark,
            // We don't have to use the same surface mode in dark mode, for an
            // interesting effect here we use a mode where scaffold background
            // color gets a much higher blend value than surface and background.
            surfaceMode: FlexSurfaceMode.highScaffoldLowSurfaces,
            // You don't have to use same blend level or mode in light
            // and dark mode, here we use a lower value in dark mode, that
            // goes better together with the highScaffoldLowSurfaces mode.
            blendLevel: 15,
            appBarElevation: 1,
            useSubThemes: themeController.useSubThemes,
            visualDensity: FlexColorScheme.comfortablePlatformDensity,
            fontFamily: GoogleFonts.notoSans().fontFamily,
          ),
          themeMode: themeController.themeMode,
          // This simple example app has only one page.
          home: HomePage(
            // Pass in the FlexSchemeData we use for the active theme.
            flexSchemeData: themeController.usedScheme == FlexScheme.custom
                    ? _myFlexScheme
                    : FlexColor.schemes[themeController.usedScheme]!,
            // Pass in the theme controller to the home page.
            controller: themeController,
          ),
        );
      },
    );
  }
}
 ```

We select used theme for the app by using the theme controller's
`usedScheme` property, that contains the value of currently selected
`FlexScheme` enum. If it is the `custom` value, we use our custom scheme
`myFlexScheme` colors. If it is any other value, we get the corresponding
colors from the `FlexColor.schemes` map, using the enum value as key.

On the `HomePage` we have a Flutter SDK `ToggleButtons` UI widget, that
allows us the select 4 different `FlexScheme` enum values, it changes the
`themeController` accordingly. The used enum values we can use are
`hippieBlue`, `mallardGreen`, `outerSpace` and the `custom` option.

You can find the simple `ToggleButtons` based enum value selector
[here](https://github.com/rydmike/flex_color_scheme/blob/master/example/lib/shared/widgets/app/theme_select_buttons.dart).

The `themeController` is also used to decide if we opt in or out on using
the new sub theming via `useSubThemes`. A simple on/off switch on the `HomePage`
allows us to toggle its state between true and false, thus turning on or off
the usage of FlexColorScheme's sub theming feature.

Below are the four resulting themes with their light and dark modes, that we
can select and use in this example.

[<img src="https://rydmike.com/assets_fcsv4/23-example-3-a-small.jpg?raw=true" alt="ColorScheme example 3 light" />](https://rydmike.com/assets_fcsv4/23-example-3-a.png?raw=true)
[<img src="https://rydmike.com/assets_fcsv4/23-example-3-b-small.jpg?raw=true" alt="ColorScheme example 3 dark" />](https://rydmike.com/assets_fcsv4/23-example-3-b.png?raw=true)
_Example 3) Using three built-in schemes, plus a custom color scheme
as application theme options. (click image to open hires version)_

Scroll down in the app to see the theme showcase further below. It presents the
theme with common Material UI widgets. You can try this example as a Flutter
[web app here](https://rydmike.com/flexcolorschemeV4Tut3).

## Example 4 - All Themes

This example shows how you can use all the built-in color schemes, plus three
custom color schemes. How to select which one of these schemes is used to
define the active theme.

The example also uses primary color blending on background and
surface colors. A subpage is available that shows the same theme applied when
opening another page, that in Flutter just inherits the same theme.

> The full code is not shown below, only highlights.
> Please find the complete example code
> [here](https://github.com/rydmike/flex_color_scheme/tree/master/example/lib/example4).

The `main` start function of the app is very similar to example 3.
However, here we use the popular package [Hive](https://pub.dev/packages/hive) to
persist settings and persist the theme settings with a `ThemeServiceHive`
instead of using the `ThemeServicePrefs` service.

> #### Why do we use Hive here and not SharedPreferences?
>
> The examples are all built using same "example" app. If we use
> SharedPreferences in more than one of the apps
> they would use the same storage container and share the settings when you
> build them locally. By using Hive for most examples, we can change
> the storage container name for each example. In these demos the
> SharedPreferences service is only used for example 3.

```dart
// The ThemeServiceHive constructor requires a box name, the others do not.
// The box name is just a file name for the file that stores the settings.
final ThemeService themeService = ThemeServiceHive('flex_scheme_box_4');
// Initialize the theme service.
await themeService.init();
// Create a ThemeController that uses the ThemeService.
final ThemeController themeController = ThemeController(themeService);
// Load all the preferred theme settings, while the app is loading, before
// MaterialApp is created. This prevents a sudden theme change when the app
// is first displayed.
await themeController.loadAll();
// Run the app and pass in the ThemeController. The app listens to the
// ThemeController for changes.
runApp(DemoApp(themeController: themeController));
```

Instead of having having our final and const color and scheme definitions
values in the main file, we moved them into a static class called
[AppColor](https://github.com/rydmike/flex_color_scheme/blob/master/example/lib/shared/const/app_color.dart).

There we begin by defining the same colors that we used in example 2 and 3,
to be our first custom color. In this case we also assign a custom color
to the optional `appBarColor`.

```dart
// Create a custom flex scheme color for a light theme.
static const FlexSchemeColor _myScheme1Light = FlexSchemeColor(
  primary: Color(0xFF00296B),
  primaryContainer: Color(0xFF2F5C91),
  secondary: Color(0xFFFF7B00),
  secondaryContainer: Color(0xFFFDB100),
  // The built in schemes use their secondary container color as their
  // custom app bar color, but it can be any color. We use a custom color
  // here. We will see this in example 5 when using the theme and selecting
  // the custom app bar style.
  appBarColor: Color(0xFFf95738),
);
// Create a corresponding custom flex scheme color for a dark theme.
static const FlexSchemeColor _myScheme1Dark = FlexSchemeColor(
  primary: Color(0xFF6B8BC3),
  primaryContainer: Color(0xFF4874AA),
  secondary: Color(0xffff7155),
  secondaryContainer: Color(0xFFF1CB9D),
  appBarColor: Color(0xFF892807),
);
```

You can build a scheme the long way, by specifying all the required
scheme colors, like above, or you can also build schemes from a
single primary color. With the `FlexSchemeColor.from` factory. When doing so
the only required color is the primary color, the other colors will be
computed. You can optionally also provide the `primaryContainer`, `secondary` and
`secondaryContainer` colors with the factory, but any color that is not provided
will always be computed to get all the required colors in `FlexSchemeColor`.

In this example we create our 2nd scheme from just a primary color for the
light and dark schemes. The custom `appBarColor` does in this case also receive
the same color value as the one that is computed for `secondaryContainer`
color. This is its default with the `FlexSchemeColor.from` factory if the
color is not specified.

```dart
 // Vivid green colors.
static final FlexSchemeColor _myScheme2Light =
FlexSchemeColor.from(primary: const Color(0xFF055C34));
static final FlexSchemeColor _myScheme2Dark =
FlexSchemeColor.from(primary: const Color(0xFF629F80));
```

For our 3rd custom color scheme we define primary and secondary colors,
but no container colors, we will not make any dark scheme definitions either, all
these missing colors will be computed. The missing color definitions will
get computed by the factory `FlexSchemeColor.from` when it creates the
`FlexSchemeColor` object. To make our dark colors for this light scheme, we
use the method `toDark` further below with the `_myScheme3Light` instance.


```dart
  // Blue and red colors, for a classic blue and red theme.
 final FlexSchemeColor myScheme3Light = FlexSchemeColor.from(
  primary: const Color(0xFF04368E),
  secondary: const Color(0xFFA00505),
 );
```

Next we create a list `AppData.schemes`, with all the color schemes we will use.
Starting with our three custom color schemes. Normally when we make custom
schemes, those are probably the ones we want to use primarily, so we put them
first in our preferred order. After our custom schemes, we add all the
pre-defined built-in ones, offering them as options users can switch to
and use if they like.

> A **FlexSchemeData** object stores `name` and `description` plus the
> matching `FlexSchemeColor` for `light` and `dark` mode color schemes.

```dart
static final List<FlexSchemeData> schemes = <FlexSchemeData>[
  // We add our custom light and dark FlexSchemeColor schemes we defined
  // to a list of FlexSchemeData, where we can bundle each light and dark
  // theme that goes together and give it a name and description too.
  const FlexSchemeData(
    name: 'C1: Midnight',
    description: 'Midnight blue theme, created by using custom color values '
            'for all colors in the scheme',
    // FlexSchemeData holds separate defined color schemes for light and
    // matching dark theme colors. Dark theme colors typically need to be less
    // saturated versions of their than light counter parts. Using the same
    // colors in light and dark theme modes does not work so well.
    light: _myScheme1Light,
    dark: _myScheme1Dark,
  ),
  // Do the same for our second custom scheme.
  FlexSchemeData(
    name: 'C2: Greens',
    description: 'Vivid green theme, created from one primary color in light '
            'mode and another primary for dark mode',
    light: _myScheme2Light,
    dark: _myScheme2Dark,
  ),
  // We also do the same for our 3rd custom scheme, BUT we create its matching
  // dark colors, from the light FlexSchemeColor with the toDark method.
  FlexSchemeData(
    name: 'C3: Red & Blue',
    description: 'Classic read and blue, created from only light theme mode '
            'primary and secondary colors',
    light: _myScheme3Light,
    // We create the dark desaturated colors from the light scheme.
    dark: _myScheme3Light.toDark(),
  ),
  // Unpack all built-in FlexColor schemes using spread operator into our list.
  ...FlexColor.schemesList,
];
```

The setup of the `MaterialApp` is as simple as in the previous example and
almost identical, for demonstration purposes we use other values for
`surfaceMode` and its `blendLevel`. We also use values for the choice
of `visualDensity` and `fontFamily` from a static `AppData` class.

```dart
class DemoApp extends StatelessWidget {
  const DemoApp({Key? key, required this.themeController}) : super(key: key);
  final ThemeController themeController;

  @override
  Widget build(BuildContext context) {
    // Whenever the user updates theme settings, the MaterialApp is rebuilt.
    return AnimatedBuilder(
      animation: themeController,
      builder: (BuildContext context, Widget? child) {
        return MaterialApp(
          debugShowCheckedModeBanner: false,
          scrollBehavior: AppScrollBehavior(),
          title: 'All Themes',
          // Define the light theme for the app, using current scheme index.
          theme: FlexThemeData.light(
            // We moved the definition of the list of color schemes to use into
            // a separate static class and list. We use the theme controller
            // to change the index of used color scheme from the list.
            colors: AppColor.schemes[themeController.schemeIndex].light,
            // Here we use another surface blend mode, where the scaffold
            // background gets a strong blend. This type is commonly used
            // on web/desktop when you wrap content on the scaffold in a
            // card that has a lighter background.
            surfaceMode: FlexSurfaceMode.highScaffoldLowSurfaces,
            // Our content is not all wrapped in cards in this demo, so
            // we keep the blend level fairly low for good contrast.
            blendLevel: 5,
            appBarElevation: 0.5,
            useSubThemes: themeController.useSubThemes,
            // In this example we use the values for visual density and font
            // from a single static source, so we can change it easily there.
            visualDensity: AppData.visualDensity,
            fontFamily: AppData.font,
          ),
          // We do the exact same definition for the dark theme, but using
          // FlexThemeData.dark() and the dark FlexSchemeColors in our
          // AppColor.schemes list instead.
          darkTheme: FlexThemeData.dark(
            colors: AppColor.schemes[themeController.schemeIndex].dark,
            surfaceMode: FlexSurfaceMode.highScaffoldLowSurfaces,
            // We go with a slightly stronger blend in dark mode. It is worth
            // noticing, that in light mode, the alpha value used for the blends
            // is the blend level value, but in dark mode it is 2x this value.
            // Visually they match fairly well, but it depends on how saturated
            // your dark mode primary color is.
            blendLevel: 7,
            appBarElevation: 0.5,
            useSubThemes: themeController.useSubThemes,
            visualDensity: AppData.visualDensity,
            fontFamily: AppData.font,
          ),
          // Use the dark or light theme based on controller setting.
          themeMode: themeController.themeMode,
          // Here we only pass the theme controller to the HomePage.
          home: HomePage(controller: themeController),
        );
      },
    );
  }
}
 ```

To select which of the 39 themes we use, becomes as simple as
giving the `themeController.schemeIndex` the index value of the color scheme
we want to use. We do that with a simple popup menu button on the `HomePage`.
This is a standard Flutter SDK UI widget, you can find how it is set up
for this use case
[here](https://github.com/rydmike/flex_color_scheme/blob/master/example/lib/example4/widgets/theme_popup_menu.dart).

In the app you can then use the popup menu available in the ListTile, showing the
current theme to change the active theme. You can choose any of the built-in 36
schemes, plus the three custom color schemes we added.

When you change scheme, you will notice that the active theme color changes are
animated by interpolating from the active theme colors, to the new theme colors.
This is a very nice standard feature when you modify the theme used by a Flutter
Material application.

When you build **Example 4**, it starts with the **Blue whale** theme.

[<img src="https://rydmike.com/assets_fcsv4/24-example-4-a-small.jpg?raw=true" alt="ColorScheme example 4 light" />](https://rydmike.com/assets_fcsv4/24-example-4-a.png?raw=true)
[<img src="https://rydmike.com/assets_fcsv4/24-example-4-b-small.jpg?raw=true" alt="ColorScheme example 4 dark" />](https://rydmike.com/assets_fcsv4/24-example-4-b.png?raw=true)
_Example 4) Using custom schemes, plus all the built-in ones as application
theme options (click image to open hires version)_

Scroll down in the app to see the theme showcase further below. It presents the
theme with common Material UI widgets. You can try this example as a Flutter
[web app here](https://rydmike.com/flexcolorschemeV4Tut4).

## Example 5 - Themes Playground

This example shows how you can use all the built-in color schemes in
FlexColorScheme to define themes from them. How you can set up your own
custom scheme colors, and use them together with the predefined ones. Like the
previous example, this can give you an idea of how you can create your own
complete custom list of color schemes if you do not want to use the predefined
ones.

This example also shows how you can use and vary the surface blend modes, change
the blend strength. You can see how the quick custom AppBar theme and its companion
TabBar theme works. The usage of the true black feature for dark
themes is also demonstrated. Using the optional Windows desktop like tooltip
theme is also shown.

The example includes a responsive side menu, it gives a visual
presentation of what applications that have larger visible surfaces using
surface blends look like. The menu has working click commands that allow you to
show and hide the contents of the cards holding settings and results. On
smaller media this makes it quicker to find interesting parts. There is a choice
that allows you the reset the persisted settings back to their default values.
To make a light/dark mode quick toggle always accessible when you test options
and themes, it is also available on the side menu as a toggle.

In addition to allowing you to opt in and out of using the sub themes, this demo
also allows you to control many sub theming parameters, like adjusting the border
radius on all widgets to some other preferred value. To use the Material 3 (M3)
inspired text theme, different theme options on TextField, among many other
sub theming features.

A subpage is also available that show that the same active theme is also
applied when opening another page. This works because all built-in widgets use
the same inherited theme and use the colors in the theme in predefined ways
by default. This is a good example and explanation of why you should use
the same theme colors for your custom re-usable widgets as their default color
property values. Then theme your application to make it look the way you want
it to look, rather than defining constant color values that you apply
directly to widget color properties.

If you tried the previous examples on an Android device, you might have noticed
that the system navigation bar on Android devices does not change. It is
not themed to have matching background or theme mode that matches the active
application theme as it changes. This example shows how it can be fixed and
that the used method remain in effect when opening a subpage.

The same custom color schemes as in example 4, are also used in this example.
They are not explained here again, please
see [example 4](#example-4---all-themes) for details.

> The full code is not shown below, only highlights.
> Please find the complete example code
> [here](https://github.com/rydmike/flex_color_scheme/tree/master/example/lib/example5).

The `main` start function of the app is the same as in previous example.

```dart
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  // Use a ThemeController, which glues our theme settings to Flutter Widgets.
  //
  // The controller uses an abstract ThemeService interface to get and save the
  // settings. There are 3 implementations available to choose from:
  //
  // 0. ThemeService      - Abstract interface base class, contains defaults
  //                        values and shared storage key value strings.
  // 1. ThemeServiceMem   - Only keeps settings in memory.
  // 2. ThemeServicePrefs - Persist settings locally using SharedPreferences.
  // 3. ThemeServiceHive  - Persist settings locally using Hive.
  //
  // Here we use Hive. The examples are all built using same
  // "example" app. If we use SharedPreferences in more than one of the apps
  // they would use the same storage container and share the settings when you
  // build them locally. By using Hive for most examples, we can change
  // the storage container name for each example. In these demos the
  // SharedPreferences service is only used for example 3, but you can swap in
  // the Hive based one for it as well.

  // The ThemeServiceHive constructor requires a box name, the others do not.
  // The box name is just a file name for the file that stores the settings.
  final ThemeService themeService = ThemeServiceHive('flex_scheme_box_5');
  // Initialize the theme service.
  await themeService.init();
  // Create a ThemeController that uses the ThemeService.
  final ThemeController themeController = ThemeController(themeService);
  // Load all the preferred theme settings, while the app is loading, before
  // MaterialApp is created. This prevents a sudden theme change when the app
  // is first displayed.
  await themeController.loadAll();
  // Run the app and pass in the ThemeController. The app listens to the
  // ThemeController for changes.
  // The ThemeController controls all the myriad of Theme settings used
  // in the demo application and also persists settings with injected
  // ThemeService.
  runApp(DemoApp(themeController: themeController));
}
```

This example has a toggle that allows you to for all the schemes use `toDark`
computed dark schemes, instead of the hand tuned built-in ones. You can then
compare this result to hand-made dark themes. The `toDark` method does a
pretty good job and can even be tuned with a level property.

> If you use the `toDark` method on the last custom scheme, you will not see
any difference, because we already created its dark scheme in this
example with this method. Turning the toggle on for it, computes the same dark
scheme from the same light scheme colors again. There is a slider that
you can use to adjust the white blend level of the `toDark` method.
From its default value of 35%, to be anything from 0...100 %, you can experiment
with it and see what it does.

Additionally, this example includes a toggle that allows you to instead of
using the `FlexColorScheme.toTheme` method, use the standard Flutter
`ThemeData.from` factory to create the theme from the same color scheme
definition. We can use this toggle to see and study the differences
that `FlexThemeData` brings to the standard theme with different settings.

The code for the `MaterialApp` for this complex looking application is actually
very similar and even identical regarding its core principle to example 4.
It is just a large number of `ThemeController` values that we assign
to properties in `FlexThemeData.light` and `FlexThemeData.dark`. Plus many more
UI widgets used to set new values to the controller. The `ThemeService`
persists all the values as we change them, same way as before too. The theme
controller notifies its listeners about the change, still using the same setup
as before in our `MaterialApp` since example 2. The app then just
rebuilds the UI to reflect our new theme settings.

It gets repetitive and rather long to show the details here. It is easier to
read `main` and `MaterialApp` StatelessWidget code [here](https://github.com/rydmike/flex_color_scheme/blob/master/example/lib/example5/main.dart).
It is well commented and explains all its parts well. You can certainly
examine the `HomePage` too, I recommend doing that with an IDE though.
It is beyond the scope of this tutorial to explain all its details,
but mostly it is just simple UI layout code.

The concludes the walk through of example 5. When we build it,
the example starts with the **blue whale** color scheme.

[<img src="https://rydmike.com/assets_fcsv4/25-example-5-a-small.jpg?raw=true" alt="ColorScheme example 5 light" />](https://rydmike.com/assets_fcsv4/25-example-5-a.png?raw=true)
[<img src="https://rydmike.com/assets_fcsv4/25-example-5-b-small.jpg?raw=true" alt="ColorScheme example 5 dark" />](https://rydmike.com/assets_fcsv4/25-example-5-b.png?raw=true)
_Example 5) The Themes Playground (click image to open hires version)_

You can try the **FlexColorScheme Themes Playground** example as a Flutter
[web app here](https://rydmike.com/flexcolorschemeV4Tut5).

## Custom Themes and Automatic Flutter Source Code

After the first release of FlexColorScheme v4, example 5 was expanded with
two new major features. This did not require any changes to FlexColorScheme
itself, it was just useful new features in example 5 and the
published live version of it. The new features make the **Themes Playground**
a very useful companion app for FlexColorScheme. It is now possible to use it
to make custom theme setups with totally custom colors, and get the colors and
theme you see, in use in your app with just a few clicks and a bit of
code copy/paste action.

In the updated version of example 5, published as the
[Themes Playground](https://rydmike.com/flexcolorschemeV4Tut5), these
new features and tools are available:

**Custom Color Scheme**
Copy an existing color scheme's colors to a custom scheme, that can then
be modified by using a color picker. In this case by using
[FlexColorPicker](https://pub.dev/packages/flex_color_picker).
It has an interesting feature that names all colors, a practical copy/paste
color values feature, and it also allows you to enter a color
using its hex RGB color value.


**Get Setup Source Code**
The Themes Playground can now also generate the code needed for you to
make the same FlexColorScheme based theme you currently see, in your own app.

Using the **Get the code for this theme** feature, you can just copy and
paste the current seen `FlexColorScheme` configuration from it, to your own
application. Then just use it without even knowing what all the properties do.
You can just go by what looks OK to you in the **Themes Playground**, copy
its setup code and use it as it is. All you have to do is copy the code and
paste it into your app.

You can find an example on how to do in this
[tweet and referenced thread](https://twitter.com/RydMike/status/1461381878494150659).

[<img src="https://rydmike.com/assets_fcsv4/09-ThemeMagic007.jpg?raw=true" alt="copy theme code" />](https://rydmike.com/assets_fcsv4/09-ThemeMagic007.png?raw=true)
_Using Themes Playground to Copy Theme Setup Source Code (click image to open hires version)_

This is the first version of this code copy/paste feature to get the
configuration code for the shown FlexColorScheme based theme. A small bit
of inception going on here, basically using FlexColorScheme to generate
code for using FlexColorScheme. If you notice any issues with it,
please open an issue in the repo.
