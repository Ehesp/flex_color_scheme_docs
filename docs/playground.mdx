# Themes Playground

**TODO: Complete the NEW guide on how to use Themes Playground V5**

This chapter goes through the basics of how to use the Themes Playground. Generally
it is simple and you probably don't need a guide, but if you get stuck on some
finer point, you might find answers here.

The [**Themes Playground**](https://rydmike.com/flexcolorscheme/themesplayground-v5)
is a useful tool to find **FlexColorScheme** themes and settings you
like. You can also use it to learn what you can do with FlexColorScheme.
The playground persists all its settings, and you can reset them back to their
default values, so don't be afraid to experiment.

The most useful feature of the **Themes Playground** is that it can
generate the Dart and Flutter FlexColorScheme setup code needed to
produce the shown active theme configuration. It even shows and modifies the
setup code as you change settings, and you can see the code side-by-side as
you change settings. This is also a fun way to get familiar with the API too,
additionally fiddling with the different themes and settings can be quite
addictive.

The **Themes Playground** can be used as a
[web app here](https://rydmike.com/flexcolorscheme/themesplayground-v5).

## Open Source

The **Themes Playground** application is open source and is bundled with
in the `FlexColorScheme` package example sub-folder. In its GitHub repository
you can find it here
[/example/lib/example5](https://github.com/rydmike/flex_color_scheme/tree/master/example/lib/example5).

The playground is also the last step in the package tutorial series. The tutorial goes
through its main used features that are relevant to using `FlexColorScheme`,
and features that differ from the previous examples. It does not go through all
the details of the application. You are welcome to study its source code for
more insights if it is of interest. It is on purposes a bit excessively
commented. The tutorial also talks about it's background, design choices
and limitations.

All the example apps are built from the example folder source code
included with the package. The web builds and deployments are automated using
GitHub actions, that are included in the GitHub repository as well.

## Two Layouts

The Themes Playground application offers two view modes.

1. Topic based page views.
2. Topic based collapsible panels, in a large masonry style grid view.

Both views have their pros and cons. On smaller screens and phone
devices, the topic based page view is more practical to use.

The masonry based grid view is best experienced at as high resolution as
possible, preferably even 4k.

Both views are very responsive and work very well down to small phone media
sizes, even in landscape mode. Still they both benefit a lot from larger
media sizes. Mostly because when you use a larger screen with high resolution,
you can see the result of more settings at one glance.

<table>
  <tr>
    <td><img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-01-pageview-3.gif?raw=true" alt="page view demo"/></td>
  </tr>
  <tr>
    <td> **_Themes Playground - Topic based page view, responsiveness demo_** </td>
  </tr>
</table>

The page view becomes more useful at typical landscape tablet sizes or larger.
At those sizes you can see the generated setup code in a side-by-side view,
on each page's configuration topic.

<table>
  <tr>
    <td><img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-02-masonryview-2.gif?raw=true" alt="masonry view demo"/></td>
  </tr>
  <tr>
    <td> **_Themes Playground - Masonry grid view with collapsible topic panels, responsiveness demo_** </td>
  </tr>
</table>

With the masonry grid, you can open and close multiple panels, including the
code view, and change settings across multiple panels and see the impact on
all of them. Sometimes having the right combination of panels with different
topics open at the same time, is useful in order to see and understand the
impact of different theme settings. While some settings are by their nature
limited to only affecting the components shown on the same topic page. We will
explore some examples of both cases.

## Interactive Theme

When you change settings in this application, be it colors, border radius and
other styles, it is important to recognize that there is **no** code
in this application, or the other examples, that sets color and style on any of
the displayed components being modified.

What is happening is that you are manipulating the global theme
for the application, and the application is being rebuilt with a new theme
interactively and in real time, every time as you modify settings that
create a new `ThemeData`. This is not something you would do in a typical
application, not to the extent this application does it anyway.

Some of the theme changes can be a bit taxing calculation
wise. Additionally some changes that appear to be lagging behind, are so for
a reason. The `MaterialApp` always lerp animates a theme change from
previous `ThemeData` value, to the new one. For example, when you drag sliders
to change border radius, this triggers an animation from a complete
`ThemeData` based on the previous slider value to the next one value, for
every rapid slider value change. This can be seen as a slight delay in the
manifestation of the latest values, as the theme is animating to the last
slider value.


<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-03-radius-change-1.gif?raw=true"
caption="ThemeData animated change continues a bit after slider change stops, plus realtime code update"
alt="border change radius demo" zoom />

<table>
  <tr>
    <td><Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-03-radius-change-1.gif?raw=true" alt="border change radius demo" zoom /></td>
  </tr>
  <tr>
    <td> **_ThemeData animated change continues a bit after slider change stops, plus realtime code update_** </td>
  </tr>
</table>

**TODO: GIF links opened as download GIF, not in full screen view! Other option to view in full screen mode?**

In the above recording you can see how the application's look and all
widgets in it, change as we turn on FlexColorScheme theming from being
completely OFF to ON and then turn on using component sub-themes, and last as
we manipulate the `defaultBorder` radius for all widgets. Observe that it changes
buttons, cards and other elements used by the application itself.

## The Code View

When you open the page view on a large enough screen you will see the generated
setup code, side-by-side with the settings you are changing. Not only is the
entire theme of application changing as you are changing settings interactively,
the code generated that you need to setup the same theme is changing as you
change settings too.

In the above screen recoding you can se this, pay attention
to the `defaultRadius` value above as the slider is dragged around.

The produced code excludes code when default values can be used, and also
settings that may become redundant or covered by some other setting.

## Copy Setup Code

Whenever you want the code you can copy it to the clipboard with the copy
button and paste it into you IDE to use.

You can also at any time in any view, use the drawer, side rail or side menu
action item "Copy theme code". This will open a dialog that shows the current
theme setup code with a copy icon as well. This action button and dialog
view can be useful on smaller sized media where you cannot see the code side
by side, like phones and tablet in vertical view.

<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-04-copy-code.png?raw=true"
caption="Copy theme setup code, via side action or COPY button in code view"
alt="Copy code" zoom />

Once you have copied the code for the setup you configured, you can paste as is
into you application, or use it as base for further modifications. You can
also paint and select only parts of the code.

If you want to quickly test out themes on a pre-made template app, you
can use the [Copy Playground Theme](/copy_playground), it is useful since it
includes presentation of all colors and common Flutter Material UI widgets,
so you can see and verify that the theme looks as intended.


## Smart Controls

The user interface also disables controls and settings that are not available
in any conflicting setup. When you turn OFF FlexColorScheme there is
not many controls that can be operated, with opinionated component sub-themes
OFF most controls are still disabled.

<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-05-unavailable-controls.png?raw=true"
caption="Controls that have no function in a given configuration are disabled"
alt="Unavailable controls" zoom />
_Controls that have no function in a given configuration are disabled_

When you enable component sub-themes, most controls are available. However there
are a few that are disabled in certain combination or only appear under given
conditions. Like using computed dark theme, or which color input to use on custom
dark theme as keep color for the seeded ColorSchemes, to mention a few.

<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-06-available-controls.png?raw=true"
caption="Most controls are available when component themes are enabled"
alt="Available controls" zoom />
_Most controls are available when component themes are enabled_

Controls also know and show different default values depending on your settings.
If you turn OFF using FlexColorScheme, toggle using component sub-themes, and
even change using the default radius to a fixed value. Widgets know and tell you
what their default value is in each situation.

The default value in each situation, means the default style and behavior a
component will use when any give property is undefined.
When you turn OFF using component themes, ot FlexColorscheme entirely, it again
shows its default in that mode, and radius widget also become disabled.

[<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-06-available-controls.png?raw=true"
caption="Border radius defaults with no components themes, typically results in Flutter SDK defaults"
alt="Defaults 1" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-06-available-controls.png?raw=true)
_Border radius defaults with no components themes, often results in Flutter SDK defaults, but not always_

This is different if FlexColorScheme is not used at all, then you are looking at
Flutter SDK default behavior for the widget. If you turn ON FlexColorScheme,
but keep component sub-themes OFF, then you are looking at the FlexColorScheme
[core defaults](/core_defaults). With sub-themes on, you again get different
defaults.

If you in it keep `defaultRadius` undefined, then each widget will
have its own default border radius and show that value when an individual widget
border radius has not been specified with its slider.

[<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-08-smart-controls02?raw=true"
caption="Border radius defaults with component themes, defaults per widget to its M3 radius specification"
alt="Defaults 2" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-08-smart-controls02?raw=true)
_Border radius defaults with component themes, defaults per widget to its M3 radius specification_

If you set a global default radius, component themes will show that values as their
default border radius when not defined and also state it comes from the global
border radius default.

<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-09-smart-controls03?raw=true" alt="Defaults 3" zoom />
_Border radius using defined global default radius and with a component theme override_

Small details like this, helps you keep on top of what default values are used
when, and controls are only available when they actually have an impact on
the resulting theme.

## Input Colors

The input colors is you viw into the details of what your actual input colors
are. There ar also some tools you can use to manipulate the input color.
Like swapping primary and secondary colors. Reducing the amount os used colors,
and in dark mode using computed dark theme. Which is useful if you have only
defined colors for your light time.

**TODO: Add images**

## Seeded ColorScheme

Using seeded ColorScheme is a way to use the Material 3 color scheme generation
tool, that generates complete and well balanced `ColorScheme`s for both
light and dark mode, from input key colors.

Flutter only directly offers using a single color a main, or primary color, as
seed color for the generated ColorScheme. With FlexColorScheme, you can use
the same setup, but you can also go further and use secondary and tertiary input
key colors to generate the ColorScheme.

These key colors could also be extracted and sourced from images, like e.g.
the device wall-paper, or even from image used in an app or seen in a flow
of images.



**TODO: Add images**
