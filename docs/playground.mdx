# Themes Playground

**TODO: Complete the NEW guide on how to use Themes Playground V5**

This chapter goes through the basics of how to use the Themes Playground. Generally
it is simple and you probably don't need a guide, but if you get stuck on some
finer point, you might find answers here.

The [**Themes Playground**](https://rydmike.com/flexcolorscheme/themesplayground-v5)
is a useful tool to find **FlexColorScheme** themes and settings you
like. You can also use it to learn what you can do with FlexColorScheme.
The playground persists all its settings, and you can reset them back to their
default values, so don't be afraid to experiment.

The most useful feature of the **Themes Playground** is that it can
generate the Dart and Flutter FlexColorScheme setup code needed to
produce the shown active theme configuration. It even shows and modifies the
setup code as you change settings, and you can see the code side-by-side as
you change settings. This is also a fun way to get familiar with the API too,
additionally fiddling with the different themes and settings can be quite
addictive.

The **Themes Playground** can be used as a
[web app here](https://rydmike.com/flexcolorscheme/themesplayground-v5).

## Open Source

The **Themes Playground** application is open source and is bundled with
in the `FlexColorScheme` package example sub-folder. In its GitHub repository
you can find it here
[/example/lib/example5](https://github.com/rydmike/flex_color_scheme/tree/master/example/lib/example5).

The playground is also the last step in the package tutorial series. The tutorial goes
through its main used features that are relevant to using `FlexColorScheme`,
and features that differ from the previous examples. It does not go through all
the details of the application. You are welcome to study its source code for
more insights if it is of interest. It is on purposes a bit excessively
commented. The tutorial also talks about it's background, design choices
and limitations.

All the example apps are built from the example folder source code
included with the package. The web builds and deployments are automated using
GitHub actions, that are included in the GitHub repository as well.

## Two Layouts

The Themes Playground application offers two view modes.

1. Topic based page views.
2. Topic based collapsible panels, in a large masonry style grid view.

Both views have their pros and cons. On smaller screens and phone
devices, the topic based page view is more practical to use.

The masonry based grid view is best experienced at as high resolution as
possible, preferably even 4k.

Both views are very responsive and work very well down to small phone media
sizes, even in landscape mode. Still they both benefit a lot from larger
media sizes. Mostly because when you use a larger screen with high resolution,
you can see the result of more settings at one glance.



The page view becomes more useful at typical landscape tablet sizes or larger.
At those sizes you can see the generated setup code in a side-by-side view,
on each page's configuration topic.

<Tabs
  defaultValue="page"
  values={[
    {label: 'Page View', value: 'page'},
    {label: 'Masonry Grid View', value: 'masonry'},
  ]}>
  <TabItem value="page">
    <Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-01-pageview-3.gif?raw=true"
    caption="Themes Playground - Topic based page view, responsiveness demo."
    alt="page view demo"/>
  </TabItem>
  <TabItem value="masonry">
    <Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-02-masonryview-2.gif?raw=true"
    caption="Themes Playground - Masonry grid view with collapsible topic panels, responsiveness demo."
    alt="masonry view demo" zoom />
  </TabItem>
</Tabs>

With the masonry grid, you can open and close multiple panels, including the
code view, and change settings across multiple panels and see the impact on
all of them. Sometimes having the right combination of panels with different
topics open at the same time, is useful in order to see and understand the
impact of different theme settings. While some settings are by their nature
limited to only affecting the components shown on the same topic page. We will
explore some examples of both cases.

## Interactive Theme

When you change settings in this application, be it colors, border radius and
other styles, it is important to recognize that there is **no** code
in this application, or the other examples, that sets color and style on any of
the displayed components being modified.

What is happening is that you are manipulating the global theme
for the application, and the application is being rebuilt with a new theme
interactively and in real time, every time as you modify settings that
create a new `ThemeData`. This is not something you would do in a typical
application, not to the extent this application does it anyway.

Some of the theme changes can be a bit taxing calculation
wise. Some changes that appear to be lagging behind, are so due to the theme
change animation. The `MaterialApp` always lerp animates a theme change from
previous `ThemeData` value, to the new `ThemeData`. For example, when you drag sliders
to change border radius, this triggers an animation from a complete
`ThemeData` based on the previous slider value to the next one, based on the new
slider value, for every rapid slider value change. This can be seen as a slight
delay in the manifestation of the latest values, as the theme is animating to the
last slider value. This can certainly be avoided by not triggering a theme change
until slider change is complete, but in this case we preferred to see the change
as the slider is being adjusted.

<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-03-radius-change-1.gif?raw=true"
caption="ThemeData animated change continues a bit after slider change stops, plus realtime code update."
alt="border change radius demo" zoom />

In the above recording you can see how the application's look, and all
widgets in it, change as we switch FlexColorScheme theming from being
completely OFF to ON, and then turn on using component sub-themes, and lastly as
we manipulate the `defaultBorder` radius for all widgets. Observe that it also
changes all buttons, cards and other elements used by the application itself.

## Code Generation

When you open the page view on a large enough screen you will see the generated
setup code, side-by-side with the settings you are changing. Not only is the
entire theme of the application changing as you modify settings interactively,
the code generated that you need to setup the same theme, is changing as you
change settings too.

In the above screen recoding you can see this. Pay for example attention
to the `defaultRadius` value above, as the slider is dragged around.

The generated code aims to exclude code when default values can be used, and
to also exclude settings that become redundant if covered by some other value.

## Copy Setup Code

Whenever you want the code, you can copy it to the clipboard with the copy
button and paste it into your IDE into your project to use it.

You can also at any time, in any view, use the drawer, side rail or side menu
action item "Copy theme code". This will open a dialog that shows the current
theme setup code with a copy icon as well. This action button and dialog
view can be useful on smaller sized media where you cannot see the code side
by side.

[<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-04-copy-code.png?raw=true"
caption="Copy theme setup code, via side action or COPY button in code view."
alt="Copy code" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-04-copy-code.png?raw=true)

Once you have copied the code for the setup you configured, you can paste it
as is into your application, or use it as base for further modifications. You can
also paint and select only parts of the code, and copy just a few lines, which
might be useful if you only modified a few settings from previous configuration.

If you want to quickly test out themes on a pre-made template app, you
can use the [Copy Playground Theme](/copy_playground), it is useful since it
includes presentation of all colors and common Flutter Material UI widgets.
You can use them to verify that the theme looks as intended.

## Smart Controls

The user interface disables controls and settings that are not available
in a given configuration. When you turn OFF FlexColorScheme, there are
not many controls that can be operated, with opinionated component sub-themes
OFF most controls are still disabled.

When you enable component sub-themes, most controls are available. However, there
are a few that are disabled in certain combination or only appear under given
conditions. Like using computed dark theme, or which color input to use on custom
dark theme as keep color for the seeded ColorSchemes, to mention a few.

<Tabs
  defaultValue="disabled"
  values={[
    {label: 'None relevant disabled', value: 'disabled'},
    {label: 'Enabled when available', value: 'enabled'},
  ]}>
  <TabItem value="disabled">
    [<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-05-unavailable-controls.png?raw=true"
    caption="Controls that have no function in a given configuration are disabled."
    alt="Unavailable controls" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-05-unavailable-controls.png?raw=true)
  </TabItem>
  <TabItem value="enabled">
    [<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-06-available-controls.png?raw=true"
    caption="Most controls are available when component themes are enabled."
    alt="Available controls" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-06-available-controls.png?raw=true)
  </TabItem>
</Tabs>

Controls also know and show different default values depending on your settings.
If you turn OFF using FlexColorScheme, toggle using component sub-themes, and
even change using the default radius to a fixed value. Widgets know and tell you
what their default value is in each situation.

The default value in each situation, means the default style and behavior a
component will use when any give property is undefined.
When you turn OFF using component themes, or FlexColorscheme entirely, it shows
the default in that mode. In the above example the radius widget also becomes
disabled.

This is different if FlexColorScheme is not used at all, then you are looking at
Flutter SDK default behavior for the widget. If you turn ON FlexColorScheme,
but keep component sub-themes OFF, then you are looking at the FlexColorScheme
[core defaults](/core_defaults). Mostly they are the same as when not using
FlexColorScheme at all, but for certain colors and elevations that they too
differ. The the FlexColorScheme [core defaults](/core_defaults) explains, how,
when and why FlexColorScheme differs from Flutter SDK.

With component sub-themes on, you again get different defaults, especially for
border radius that default to Material 3 specifications where border radius
varies a lot per component type.

If you when using component sub-themes keep `defaultRadius` undefined,
then each component widget will use its Material 3 default border radius value
and show that value when an individual widget border radius has not
been specified with its slider.

<Tabs
  defaultValue="no-component"
  values={[
    {label: 'No Component Themes - Default M2 radius', value: 'no-component'},
    {label: 'Component Themes - Default M3 radius', value: 'component-defaults'},
    {label: 'Custom default - Global default', value: 'global-default'},
  ]}>
  <TabItem value="no-component">
    [<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-07-smart-controls01.png?raw=true"
    caption="Border radius defaults with no components themes, typically results in Flutter SDK defaults."
    alt="Smart controls 1" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-07-smart-controls01.png?raw=true)
  </TabItem>
  <TabItem value="component-defaults">
    [<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-08-smart-controls02.png?raw=true"
    caption="Border radius defaults with component themes, defaults per widget to its M3 radius specification."
    alt="Smart controls 2" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-08-smart-controls02.png?raw=true)
  </TabItem>
  <TabItem value="global-default">
    [<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-09-smart-controls03.png?raw=true"
    caption="Border radius defaults with component themes, defaults per widget to its M3 radius specification."
    alt="Smart controls 3" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-09-smart-controls03.png?raw=true)
  </TabItem>
</Tabs>

When you set a global default radius, component themes will show that values as their
default border radius when not defined and also state it comes from the global
border radius default. If a component widget has specified its own border radius
it shows that value. If you then turn OFF component sub-themes, it will get
disabled and show Flutter SDK material 2 default border radius.

This type of logic applies so far to border radius and various differences in
default colors and elevation when FlexColorScheme is not used at all, is used,
but component themes are not enabled, and when enabled.

Small details like this, helps you keep on top of what default values are used
when, and controls are only available when they actually have an impact on
the resulting theme.

## Input Colors

The input colors is your view into your scheme's raw input colors. There are
some options you can use to manipulate the input colors with.
Like swapping primary and secondary colors. Reducing the amount of used colors,
and in dark mode using computed dark theme. Computed dark theme is useful if
you have only defined colors for your light time.

<Tabs
  defaultValue="given"
  values={[
    {label: 'Colors as given', value: 'given'},
    {label: 'Swap & M3 Error colors', value: 'swap'},
    {label: 'Reduce colors', value: 'reduce'},
  ]}>
  <TabItem value="given">
    [<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-10-input-01.png?raw=true"
    caption="Input colors used as given and defined."
    alt="Smart controls 1" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-10-input-01.png?raw=true)
  </TabItem>
  <TabItem value="swap">
    [<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-11-input-02.png?raw=true"
    caption="Input colors with primary and secondary swapped and using Material 3 error colors instead of Material 2"
    alt="Smart controls 1" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-11-input-02.png?raw=true)
  </TabItem>
  <TabItem value="reduce">
    [<Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-12-input-03.png?raw=true"
    caption="Theme defining input colors reduced from 6 to 4, and undefined ones computed."
    alt="Smart controls 1" zoom />](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-pg-12-input-03.png?raw=true)
  </TabItem>
</Tabs>

## Seeded ColorScheme

Using seeded ColorScheme is a way to use the Material 3 color scheme generation
tool, that generates complete and well balanced `ColorScheme`s for both
light and dark mode, from input key colors.

Flutter only directly offers using a single color a main, or primary color, as
seed color for the generated ColorScheme. With FlexColorScheme, you can use
the same setup, but you can also go further and use secondary and tertiary input
key colors to generate the ColorScheme.

These key colors could also be extracted and sourced from images, like e.g.
the device wall-paper, or even from image used in an app or seen in a flow
of images.

**TODO: Add images**

## Surface blends

**TODO: Add info and images of surface blends**
