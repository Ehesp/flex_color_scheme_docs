# API Guide

The [API reference documentation](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/flex_color_scheme-library.html)
for **FlexColorScheme** generated from code document comments is very,
it usually covers any question you might have, and more.

An overview of key APIs is presented below. It will be extended with more
information and examples in future updates to this documentation site. These
updates will be influenced by what questions users raise about the API.

You can create FlexColorScheme based `ThemeData` objects using two
different APIs:

1. **FlexThemeData** static extension on `ThemeData`.
2. **FlexColorScheme.toTheme** class and method.

## 1) FlexThemeData

API reference: [**FlexThemeData**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexThemeData.html)

There are separate APIs for creating light theme mode, and dark theme mode
`ThemeData`:

* [**FlexThemeData.light()**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexThemeData/light.html)
* [**FlexThemeData.dark()**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexThemeData/dark.html)


**Example: FlexThemeData**

Using this API is very familiar, it looks a lot like `ThemeData.light` and `dark`, but
with Flex prepended. They of course have a lot of additional properties, but
the basic usage is very simple.

```dart
  class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
    return MaterialApp(
      title: 'API Guide',
      theme: FlexThemeData.light(scheme: FlexScheme.mandyRed),
      darkTheme: FlexThemeData.dark(scheme: FlexScheme.mandyRed),
      themeMode: ThemeMode.system,
      home: MyHomePage(title: 'Flutter Demo Home Page'),
    );
```

The `FlexThemeData` is actually a static extension on `ThemeData` to define a
`FlexColorScheme` object and return the `ThemeData` object defined by
its instance, using its `FlexColorScheme.toTheme` method in one go.

Using e.g. `FlexThemeData.light()` is a bit shorter than
`FlexColorScheme.light().toTheme`, and it may feel more familiar since
you get a `ThemeData` object directly that you can use just like any
other `ThemeData` object produced by Flutter's different built-in `ThemeData`
factory constructors.

## 2) FlexColorScheme

API reference: [**FlexColorScheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexColorScheme-class.html)

The original way to create FlexColorScheme based `ThemeData` objects is to use
the package namesake
[`FlexColorScheme`](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexColorScheme-class.html)
class and then use its `toTheme` method to produce and get the `ThemeData`
object specified by your immutable `FlexColorScheme` configuration.

Usually you do **not** use the raw default [`FlexColorScheme()`](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexColorScheme/FlexColorScheme.html)
constructor to create your `FlexColorScheme` object, instead you should prefer using its factories:

* [**FlexColorScheme.light()**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexColorScheme/FlexColorScheme.light.html)
* [**FlexColorScheme.dark()**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexColorScheme/FlexColorScheme.dark.html)

These factories are used to make `FlexColorScheme` based `ThemeData` definitions for
light and dark theme mode respectively. These factory constructors offer many
additional parameters over the raw default constructor, that can be used to
create more nuanced and computed `ColorScheme` definitions, used by
the created `ThemeData`.

Here is how you would use them to define identical themes to above,
where we used `FlexThemeData.light` and `.dark`:

**Example: FlexColorScheme**

Making `ThemeData` with FlexColorScheme's name sake class, is a bit more
verbose, but does the same thing.

```dart
  class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
    return MaterialApp(
      title: 'API Guide',
      theme: FlexColorScheme.light(scheme: FlexScheme.mandyRed).toTheme,
      darkTheme: FlexColorScheme.dark(scheme: FlexScheme.mandyRed).toTheme,
      themeMode: ThemeMode.system,
      home: MyHomePage(title: 'Flutter Demo Home Page'),
    );
```

The `FlexColorScheme.light().toTheme` and `FlexThemeData.light()`, and its dark
counterparts, all have the same properties and are interchangeable.
The `light` and `dark` parameters differ slightly due to a few different
features for light and dark themes.


## Properties

Important properties for `FlexColorScheme.light()` and
`FlexThemeData.light()`, as well as for `FlexColorScheme.dark()` and
`FlexThemeData.dark()`, are presented below. The examples use `FlexThemeData`,
but they are identical when using `FlexColorScheme`.

The two most commonly used properties to define used colors in the
produced `ThemeData` are:

* **scheme** a [`FlexScheme`](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexScheme.html)
  enum value used to select which predefined color scheme to use for the theme.
* **colors** a [`FlexSchemeColor`](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSchemeColor-class.html)
  object used to define custom colors to be used to create the theme.

If you specify both `scheme` and `colors`, the custom colors in `colors` have
higher precedence and are used, and the `scheme` property is ignored.
If you specify neither, then `scheme` defaults to `FlexScheme.material`.

You can also create a custom `FlexColorScheme` based theme from a Flutter
standard `ColorScheme` object, by providing it a `colorScheme`.

* **colorScheme** a
  [`ColorScheme`](https://api.flutter.dev/flutter/material/ColorScheme-class.html)
  object used to create a custom `FlexColorScheme` based theme, from color
  definitions you already have in a standard `ColorScheme`.
  This property also exist in the default constructor. If you use `colorScheme`
  with the constructors `light` and `dark`, the colors in the provided
  `colorScheme` will override any value you have given in the `scheme` or `colors`
  properties.

* The direct color properties available in the constructors, e.g. `primary`,
  `primaryContainer`, etc., that are all named like the same color properties
  in `ColorScheme` or e.g. `scaffoldBackground` in `ThemeData`, will override
  any corresponding color values that would be set via other color affecting
  properties via `scheme`, `colors` and also the ones in a
  `colorScheme`. The direct color properties provide an
  alternative way to override individual colors values in built-in schemes,
  colors or provided `colorScheme`. Not all color properties in a `ColorScheme`
  are available is direct color property values, but commonly used ones are.

FlexColorScheme has shortcut enum properties that you can use to quickly adjust
the theme design for your **AppBar** and **TabBar**.

* **appBarStyle**
  a [`FlexAppBarStyle`](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexAppBarStyle.html)
  enum value used to define the themed color of the **AppBar** background color.
* [**tabBarStyle**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexColorScheme/tabBarStyle.html)
  a [`FlexTabBarStyle`](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTabBarStyle.html)
  enum value used to select preferred style for used **TabBarTheme** theme.

An interesting and unique feature of FlexColorScheme is its capability to
automatically create color schemes and resulting themes, that blend in the primary
color into different surfaces. You can vary this blending depending
on surface type and use different blend strengths. This feature is only available
via the factory constructors and their `ThemeData` extensions, not via the
default raw `FlexColorscheme()` constructor. To use the surface blending features
use the properties **surfaceMode** and **blendLevel**.

* **surfaceMode** a [`FlexSurfaceMode`](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSurfaceMode.html)
  enum value used to select the mode for blending in primary color into
  surface, background, scaffoldBackground and dialogBackground colors.
* **blendLevel**, integer value, sets the blend level strength
   used by the used `surfaceMode`.
   The blend level is the integer decimal value of the alpha value
   used in the alpha blend function. It mixes one color with another,
   by using alpha opacity value in the color of a surface put on top of
   another surface with opaque color, and returns the result as one opaque
   color.

* **inputColors** integer value the defines the number of the six main
scheme colors to be used when creating effective `ColorScheme`.
A convenience property that allows you to vary which colors to
use of input primary, secondary and tertiary colors and their container
colors, when FlexSchemeColor creates its effective `ColorScheme` from
the input colors. The integer number corresponds to using:
  1. Only the primary color
  2. Primary & Secondary colors
  3. Primary + container & Secondary colors
  4. Primary + container & Secondary + container
  5. Primary + container & Secondary + container & tertiary colors
  6. Primary + container & Secondary + container & tertiary + container
Computed color values are used for the ones being left out, that ar derived
from included ones.

* **swapColors** boolean value. When true, the primary and primaryContainer
  colors will be swapped with their secondary counter parts.
  Set this flag to true if you want to make a theme where
  your primary and secondary colors are swapped compared to how they
  are defined in the passed in color properties or used pre-defined
  color scheme.

  This is useful if you want to do this with the pre-defined
  schemes. If you are explicitly defining all your theme colors you can
  of course define them in any desired order. Even if you do
  that, this feature will still swap whatever colors you defined
  for primary and secondary. You can offer this feature as an easy end
  user modifiable theme option if you like. Another usage possibility is to
  set `swapColors` to true only for the dark modem and use your color
  scheme the other way around, but only in dark mode.

* **useMaterial3ErrorColors** boolean value. Set it to true to use the
   new Material 3 error colors.
   If `useMaterial3ErrorColors` is false, the resulting `ColorScheme`
   and `ThemeData` will use Material 2 default error colors or
   error colors as defined by the built in color schemes. Thus using same
   error colors as in FlexColorScheme versions before version 5.
   If `useMaterial3ErrorColors` is true, the resulting `ColorScheme`
   and `ThemeData` will use the Material 3 design guide error colors.
   Key color seed generated ColorSchemes always use the Material 3
   design guide error colors, or error colors from its customized
   `TonalPalette` generation setup.


**Example: Using above properties**

Here is what using above properties looks like:

```dart
theme: FlexThemeData.light(
  scheme: FlexScheme.flutterDash,
  usedColors: 4,
  surfaceMode: FlexSurfaceMode.highScaffoldLowSurface,
  blendLevel: 20,
  appBarStyle: FlexAppBarStyle.background,
  appBarOpacity: 0.95,
  tabBarStyle: FlexTabBarStyle.forBackground,
  swapColors: true,
  useMaterial3ErrorColors: true,
),
darkTheme: FlexThemeData.dark(
  scheme: FlexScheme.flutterDash,
  usedColors: 4,
  surfaceMode: FlexSurfaceMode.highScaffoldLowSurface,
  blendLevel: 15,
  appBarStyle: FlexAppBarStyle.background,
  appBarOpacity: 0.90,
  tabBarStyle: FlexTabBarStyle.forBackground,
  useMaterial3ErrorColors: true,
),
```

This produces an app with a theme looking like this
when we try it in the [**Copy Playground**](/copy_playground) app:


**TODO: Add images**

## Use FlexColorScheme or FlexThemeData?

When should you use `FlexColorScheme.light().toTheme` instead of
`FlexThemeData.light()`?

If all you need is the `ThemeData` object, then
you may prefer using `FlexThemeData.light()` due to its shorter and more
familiar syntax.

However, if you need access to the `ColorScheme` that
will be made by `toTheme` when it creates `ThemeData`, you may prefer
first defining a `FlexColorScheme` object. You can then use the
`FlexColorScheme.toScheme` method to get the `ColorScheme` it will use in its
created `ThemeData`. You can use this `ColorScheme` the get access to the
identical `ColorScheme`, regardless of what properties you used to define and
generate it with in your `FlexColorScheme` configuration.

**Example: Using ColorScheme from FlexColorScheme.toScheme**
You often need access to FlexColorScheme's `ColorScheme` if you make
custom component themes in order to use theme matching colors in them.

```dart
// A function to make custom ThemeData using FlexColorScheme
// and a custom ToggleButtonsThemeData component theme.
ThemeData myLightTheme({
}) {
  // We need to use the ColorScheme defined by the ThemeData that
  // FlexColorScheme will create based on our configuration in our
  // custom component theme. We first create the `FlexColorScheme` object:
  final FlexColorScheme flexScheme = FlexColorScheme.light(
    scheme: FlexScheme.flutterDash,
    surfaceMode: FlexSurfaceMode.highScaffoldLowSurface,
    blendLevel: 10,
    appBarStyle: FlexAppBarStyle.background,
    appBarOpacity: 0.95,
    tabBarStyle: FlexTabBarStyle.forBackground,
  );
  // Then get the `ColorScheme` defined by our FlexColorScheme configuration,
  // using its `toScheme` method.
  final ColorScheme colorScheme = flexScheme.toScheme;
  // We can the return the `ThemeData` from our `FlexColorScheme`, with
  // our custom component theme added to it, where its customizations uses
  // color that the `ColorScheme` in the return `ThemeData` also gets.
  return flexScheme.toTheme.copyWith(
    // Add our custom toggle buttons component theme.
    toggleButtonsTheme: toggleButtonsTheme(colorScheme),
  );
}

// ToggleButtons theme.
ToggleButtonsThemeData toggleButtonsTheme(ColorScheme colorScheme) =>
    ToggleButtonsThemeData(
      selectedColor: colorScheme.onPrimary,
      color: colorScheme.primary.withOpacity(0.85),
      fillColor: colorScheme.primary.withOpacity(0.85),
      hoverColor: colorScheme.primary.withOpacity(0.2),
      focusColor: colorScheme.primary.withOpacity(0.3),
      borderWidth: 1.5,
      borderColor: colorScheme.primary,
      selectedBorderColor: colorScheme.primary,
      borderRadius: BorderRadius.circular(20),
    );
```

Above you could also create the entire `ThemeData` from the
`FlexColorScheme` instance `flexScheme` above. Extract its `ColorScheme`
and use it to make the custom component `toggleButtonsTheme`, and then
use `copyWith` on the already created `ThemeData` that you return as
`ThemeData. Both work, the above should in theory be marginally more
resource efficient, but it probably does not matter in practice.


## Key Color Seed Generated ColorScheme

Like Flutter has `ColorScheme.fromSeed` to make delightful Material 3 specification
based computational `ColorScheme` so does `FlexColorScheme`. You can use the
identical algorithm that used by `ColorScheme.fromSeed`, but you can also
completely customize it, but still be producing `ColorScheme` that adheres
to Material 3 Color System, but primes the engine a bit differently.

Since `ColorScheme.fromSeed` only uses one single color as seed color and always
the same `ColorScheme` generation parameters, the amount of variation it provides
is a bit limited, and the results also tend to be bit soft pastel color oriented.

By priming the `FlexColorScheme` customizable `ColorScheme` generation you can
create more varied results that are not so repetitive of what has already been
seen before, even though you it still uses the same design M3 color system
design principle based on tonal palettes. You can read and see an explanation
in the Themes Playground guide about what the
[**tonal palettes**](/playground#tonal-palettes) are.

To make seed generated `ColorScheme` with FlexColorscheme, using its
effective input `primary` color as seed key, pass in a default
`FlexKeyColors()` to the `keyColors` property.

With this default you get a computed `ColorScheme` that is identical to the
one you would have gotten if you used ``ColorScheme.fromSeed` with the
effective input `primary` color from your `FlexColorScheme`.

With `FlexKeyColors` you can also use the `secondary` and `tertiary` input
colors in your `FlexColorScheme` as keys, that are then used when generating the
secondary and tertiary tonal palettes. Please see the `FlexKeyColors` API
documentation for more information about additional parameters in `FlexKeyColors`.

API reference: [**FlexKeyColors**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexKeyColors-class.html)


By specifying a `FlexTones()` configuration for `tones` in `FlexColorScheme`
you can further adjust how the `ColorScheme` generation algorithm computes
the primary, secondary and tertiary tonal palettes. The properties `Chroma` and
`MinChroma`, prepended with, `primary`, `secondary` and `tertiary` for each
tonal palette from corresponding key color, adjust how the algorithm uses
the input colors when it generates the tonal palettes from the key colors.

See API docs for details:
* [**primaryChroma**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/primaryChroma.html)
* [**primaryMinChroma**]https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/primaryMinChroma.html)
* [**secondaryChroma**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/secondaryChroma.html)
* [**secondaryMinChroma**]https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/secondaryMinChroma.html)
* [**tertiaryChroma**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/tertiaryChroma.html)
* [**tertiaryMinChroma**]https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/tertiaryMinChroma.html)

You can also modify which
tone in the generated tonal palettes is mapped to what `ColorScheme`
color, within the limits that it only allows mapping tones from
each tonal palette to the colors in the ColorScheme that use the tonal palette
in question, but you can change the default used tone to be different from the
Material 3 guide specification and values used in Flutter SDK.

To make custom `FlexTones()` it is recommend to use the theme mode appropriate
constructor `FlexTones.light()` and `FlexTones.dark()` that have defaults
that create the setup for Material 3 spec used in Flutter `ColorScheme.fromSeed`,
but where each property can be changed from the default as preferred.

There also predefined `FlexTones` configuration in addition to the default
M3 guide spec matching one, that you can use as they are, or use them as examples
of how to create your own custom `tones` configurations. Made a great one?
Please share it in the FlexColorScheme GitHub repository's show and tell
[discussions](https://github.com/rydmike/flex_color_scheme/discussions/categories/show-and-tell)
forum, maybe we can add it as another predefined option.

See API docs for more details on **FlexTones**:
* Class [**FlexTones**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones-class.html)
* Light mode default value factory [**FlexTones.light**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/FlexTones.light.html)
* Dark mode default value factory [**FlexTones.dark**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/FlexTones.dark.html)
* Material 3 spec tones constructor [FlexTones.material](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/material.html)
* Vivid tones constructor [FlexTones.vivid](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/vivid.html)
* Vivid surfaces tones constructor [FlexTones.vividSurfaces](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/vividSurfaces.html)
* Soft tones constructor [FlexTones.soft](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/soft.html)
* High contrast tones constructor [FlexTones.highContrast ](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexTones/highContrast.html)

**Example: FlexColorScheme with keyColors and tones**
Here we use a key color generated ColorScheme, and using otherwise same
property values as in the previous example.

```dart
theme: FlexThemeData.light(
  scheme: FlexScheme.flutterDash,
  usedColors: 4,
  surfaceMode: FlexSurfaceMode.highScaffoldLowSurface,
  blendLevel: 20,
  appBarStyle: FlexAppBarStyle.background,
  appBarOpacity: 0.95,
  tabBarStyle: FlexTabBarStyle.forBackground,
  swapColors: true,
  keyColors: const FlexKeyColors(
    useSecondary: true,
    useTertiary: true,
  ),
  tones: FlexTones.vivid(Brightness.light),
  visualDensity: FlexColorScheme.comfortablePlatformDensity,
),
darkTheme: FlexThemeData.dark(
  scheme: FlexScheme.flutterDash,
  usedColors: 4,
  surfaceMode: FlexSurfaceMode.highScaffoldLowSurface,
  blendLevel: 15,
  appBarStyle: FlexAppBarStyle.background,
  appBarOpacity: 0.90,
  tabBarStyle: FlexTabBarStyle.forBackground,
  keyColors: const FlexKeyColors(
    useSecondary: true,
    useTertiary: true,
  ),
  tones: FlexTones.vivid(Brightness.dark),
),
```

Above we used one of the predefined custom tone setups called `FlexTones.vivid`.
Making custom tones is simple, the code for this predefined example is:

```dart
static FlexTones vivid(Brightness brightness) =>
    brightness == Brightness.light
        ? const FlexTones.light(
            primaryTone: 30,
            primaryChroma: null,
            secondaryChroma: null,
            tertiaryChroma: null,
            primaryMinChroma: 50,
          )
        : const FlexTones.dark(
            onPrimaryTone: 10,
            primaryContainerTone: 20,
            onErrorContainerTone: 90,
            primaryChroma: null,
            secondaryChroma: null,
            tertiaryChroma: null,
            primaryMinChroma: 50,
          );
```

When we try the above `FlexThemeData` config, again in the
[**Copy Playground**](/copy_playground) app, we get an application
with this theme:

**TODO: Add images**

## Component Themes

A more opinionated theme and style can be created by passing in a default
`FlexSubThemesData()` constructor to the `FlexColorScheme` or `FlexThemeData`,
property `subThemesData`.

By default the component themes take inspiration from the Material 3 design
guide [specification](https://m3.material.io) and uses its values as
defaults when it is possible to do so in Flutter
SDK theming, still having Material 2 design theming limitations.

The component themes can configured further by configuring a large
number of properties in `FlexSubThemesData`, that is passed into
`subThemesData`. A commonly used feature is to adjust the default corner
border radius on all sub-themes for widgets that supports it.

Other opinionated changes includes a more flat design, and features like
primary tinted hover, focus, highlight and splash colors, among other things.
For full list of component theme configuration options and some other related
theme modifying properties, please see the API docs for `FlexSubThemesData`.

API reference: [**FlexSubThemesData**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemesData-class.html).

A common use case for `FlexSubThemes` is easy to
use customization of default border radius on **all** Flutter UI components
and elements that supports border radius either via [ShapeBorder]
or [BorderRadiusGeometry]. This is be done with a single property, the
[`defaultRadius`](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemesData/defaultRadius.html).

### Components Construction

When you opt-in on using the component themes, the `FlexColorScheme.toTheme`
method uses the passed in `FlexSubThemesData` configuration data object, that is
passed in via `FlexColorScheme.subThemesData`, to create the component themes using
the properties provided.

In some cases, typically for older core related "legacy" component theme cases,
the component themes are created directly in the `toTheme` method.
However, in most cases separate static sub-theme helper functions
from the `FlexSubThemes` class are used.

API reference: [FlexSubThemes](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes-class.html).

> Component themes that are only defined directly in the `toTheme` method,
> will be moved into the `FlexSubThemes` class as well in a future update.

These `FlexSubThemes` component themes are currently available and used via
their static helper functions, when `toTheme` creates `ThemeData`:

* [**buttonTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/buttonTheme.html)
* [**bottomNavigationBar**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/bottomNavigationBar.html)
* [**bottomSheetTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/bottomSheetTheme.html)
* [**cardTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/cardTheme.html)
* [**checkboxTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/checkboxTheme.html)
* [**chipTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/chipTheme.html)
* [**dialogTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/dialogTheme.html)
* [**elevatedButtonTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/elevatedButtonTheme.html)
* [**floatingActionButtonTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/floatingActionButtonTheme.html)
* [**inputDecorationTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/inputDecorationTheme.html)
* [**navigationBarTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/navigationBarTheme.html)
* [**navigationRailTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/navigationRailTheme.html)
* [**outlinedButtonTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/outlinedButtonTheme.html)
* [**popupMenuTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/popupMenuTheme.html)
* [**radioTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/radioTheme.html)
* [**snackBarTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/snackBarTheme.html)
* [**switchTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/switchTheme.html)
* [**textButtonTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/textButtonTheme.html)
* [**timePickerTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/timePickerTheme.html)
* [**toggleButtonsTheme**](https://pub.dev/documentation/flex_color_scheme/latest/flex_color_scheme/FlexSubThemes/toggleButtonsTheme.html)

You can also use these static component theme helpers without using
FlexColorScheme to define custom components themes or even without using
FlexColorScheme at all. You can further modify the component helper  themes'
produced results by using their `copyWith`. The helpers be simpler to
use than the raw component theme constructors, or your can just study to
see how some component theme is made that interests you.
