# Ways to ThemeData

In this chapter we compare different ways to define and create a `ThemeData`
object and look at the differences we get in effective **colors** in the theme-
We will look at using these options, in both light and dark mode, dark is just
not mentioned below, it go too long:

1. ThemeData.light() and ThemeData(brightness: Brightness.light)
2. ThemeData(primarySwatch: Colors.blue)
3. ThemeData(colorScheme: ColorScheme.fromSwatch())
4. ThemeData.from(colorScheme: ColorScheme.fromSwatch())
5. ThemeData(colorScheme: ColorScheme())
6. ThemeData.from(colorScheme: ColorScheme())
7. ThemeData(colorSchemeSeed: Color()),
8. ThemeData(colorScheme: ColorScheme.fromSeed(seedColor: Color())),
9. ThemeData.from(colorScheme: ColorScheme.fromSeed(seedColor: Color())),
10. FlexThemeData.light(colorScheme)
11. FlexThemeData.light(colorScheme, keyColors)
12. FlexThemeData.light(colorScheme, keyColors, subThemesData)

We will compare the results and discuss findings. Yes that's a lot of methods
to make a `ThemeData` object. Last three ones are **FlexColorScheme** ways
with some different parameters. Recommendations on what to use when will also
be given.

## Reference Scheme

To make it interesting we will use the `ColorScheme` M3 Guide Baseline as input
for a fully qualified `ColorScheme`. We will however use the `FlexColorScheme`
input colors version, that has less colorful onColors as a starting point. When we
use seeded ColorSchemes with it, we will also get the more colorful colors as
specified in the M3 guide.

This is scheme is helpful for this study, because when we use its main color as
seed color, the M3 algorithm actually produces the same `ColorScheme` as the
full M3 guide spec version of this ColorScheme. This happens because the
colors used in the guide design M3 Baseline `ColorScheme`, have been produced
using the same input Color and same algorithm. This helps us spot differences
in the result easier, since we will not be focused on the color generation
differences, but rather on where the colors end up in the produced `ThemeData`.


For reference, here is the used M3 baseline light theme mode `ColorScheme` without
M3 colorful onColors.

```dart
const ColorScheme flexSchemeLight = ColorScheme(
  brightness: Brightness.light,
  primary: Color(0xff6750a4),
  onPrimary: Color(0xffffffff),
  primaryContainer: Color(0xffeaddff),
  onPrimaryContainer: Color(0xff000000),
  secondary: Color(0xff625b71),
  onSecondary: Color(0xffffffff),
  secondaryContainer: Color(0xffe8def8),
  onSecondaryContainer: Color(0xff000000),
  tertiary: Color(0xff7d5260),
  onTertiary: Color(0xffffffff),
  tertiaryContainer: Color(0xffffd8e4),
  onTertiaryContainer: Color(0xff000000),
  error: Color(0xffb00020),
  onError: Color(0xffffffff),
  errorContainer: Color(0xfffcd8df),
  onErrorContainer: Color(0xff000000),
  outline: Color(0xff4d4d4d),
  background: Color(0xffffffff),
  onBackground: Color(0xff000000),
  surface: Color(0xffffffff),
  onSurface: Color(0xff000000),
  surfaceVariant: Color(0xffffffff),
  onSurfaceVariant: Color(0xff000000),
  inverseSurface: Color(0xff121212),
  onInverseSurface: Color(0xffffffff),
  inversePrimary: Color(0xfff0e9ff),
  shadow: Color(0xff000000),
);
```

And here the dark theme mode one without M3 colorful onColors.

```dart
const ColorScheme flexSchemeDark = ColorScheme(
  brightness: Brightness.dark,
  primary: Color(0xffd0bcff),
  onPrimary: Color(0xff000000),
  primaryContainer: Color(0xff4f378b),
  onPrimaryContainer: Color(0xffffffff),
  secondary: Color(0xffccc2dc),
  onSecondary: Color(0xff000000),
  secondaryContainer: Color(0xff4a4458),
  onSecondaryContainer: Color(0xffffffff),
  tertiary: Color(0xffefb8c8),
  onTertiary: Color(0xff000000),
  tertiaryContainer: Color(0xff633b48),
  onTertiaryContainer: Color(0xffffffff),
  error: Color(0xffcf6679),
  onError: Color(0xff000000),
  errorContainer: Color(0xffb1384e),
  onErrorContainer: Color(0xffffffff),
  outline: Color(0xffb3b3b3),
  background: Color(0xff121212),
  onBackground: Color(0xffffffff),
  surface: Color(0xff121212),
  onSurface: Color(0xffffffff),
  surfaceVariant: Color(0xff121212),
  onSurfaceVariant: Color(0xffffffff),
  inverseSurface: Color(0xffffffff),
  onInverseSurface: Color(0xff000000),
  inversePrimary: Color(0xff635b70),
  shadow: Color(0xff000000),
);
```

The above enables easy copy/paste of them for verification. To show the colors
we can use our IDE of choice that show the colors too.

 <Tabs
  defaultValue="light"
  values={[
    {label: 'Light M3 Baseline', value: 'light'},
    {label: 'Dark M3 Baseline', value: 'dark'},
  ]}>
  <TabItem value="light">
    <Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-00-a-scheme-light.png?raw=true"
    caption="Used M3 Baseline light ColorScheme for ThemeData results difference comparison"
    alt="M3 Baseline light"/>
  </TabItem>
  <TabItem value="dark">
    <Image src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-00-b-scheme-dark.png?raw=true"
    caption="Used M3 Baseline dark ColorScheme for ThemeData results difference comparison"
    alt="M3 Baseline dark" zoom />
  </TabItem>
</Tabs>


 The older `ThemeData` creation methods are `ColorSwatch` based, or actually
 `MaterialColor` based, a super class of `ColorSwatch`. We cannot use a
 `ColorScheme` to create themes from the above `ColorScheme` and there is
 no built-in `MaterialColor` swatch that is directly similar to the purple
 based Material 3 Baseline `ColorScheme`.

 FlexColorScheme and FlexColorPicker both contain a helper that can create a
 `MaterialColor` swatch from a single selected color. The algorithm is very simple,
 it is not the actual `MaterialColor` used to create the built in colors.
 Its results depend a lot on the used color, as it assume the provided color
 is the mid-point 500 shade. We can use the light theme mode primary color from
 the above `ColorScheme` and create a `MaterialColor` swatch from it.

 <img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-00-c-swatch.png?raw=true" alt="Flex purple swatch"/>

 What does this custom `MaterialColor` look like? The `FlexColorPicker` in
 the **Themes Playground** app can show it to us. Copy the "M3 Baseline" theme
 to the customizable theme and then select the primary color, having color value
 *0xff6750a4**. With this color selected, the wheel picker will draw its
 **Material Color** swatch, created using this color using the same
 `createPrimarySwatch` function. Below  it you will also see the primary
 tonal palette for the same input color.

<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-00-d-swatch-image.png?raw=true" alt="Swatch picker image"/>


### Swatch Based

Let's call this group of themes **Swatch** based, since they all either
directly or under the hood via defaults, use the old `MaterialColor`
color swatches as base to create `ThemeData` and its colors.

These methods are practically obsolete when it comes to producing
`ColorScheme` based `ThemeData`. Some of them don't even accept a
`ColorScheme` as input, nor do they produce an app with a very
usable `ColorScheme`.
The methods are not deprecated, but it is stated in code comments that
these are not the preferred way to make color correct `ThemeData`. Let's
find out why they are not recommend.

### 1) TD.light

Since these methods do not accept a `ColorScheme` as input, we will use
`MaterialColor` swatch as input, and we will use our custom `flexSwatch`, when
possible.

We start with theme methods `ThemeData.light()` and `ThemeData.dark()`. These
are just small Flutter SDK convenience factories based on this code:

```dart
  /// A default light blue theme.
  factory ThemeData.light() => ThemeData(brightness: Brightness.light);
  /// A default dark theme with a teal secondary [ColorScheme] color.
  factory ThemeData.dark() => ThemeData(brightness: Brightness.dark);
```

These shortcuts are in fact only marginally shorter than using the syntax used
for what they return. It is a bit unclear why they even exits, but they do.
They are not very practical when you make a `ThemeData` object, since you
cannot define any other properties for them directly. You would have to apply
all of them with `copyWith`, if we create our `ThemeData` like this:

```dart
// 1b) TD.light
//     ThemeData.light() / ThemeData.light().dark()
title: '1a) TD.light',
theme: ThemeData.light(),
darkTheme: ThemeData.dark(),
```

All we can get with the above is the default `Colors.blue` `MaterialColor`
swatch based `ThemeData`, not very practical. This is of course going to
be identical to:

```dart
// 1a) TD brightness
//     ThemeData(brightness: Brightness.light)
//     ThemeData(brightness: Brightness.dark)
title: '1b) TD brightness',
theme: ThemeData(brightness: Brightness.light),
darkTheme: ThemeData(brightness: Brightness.dark),
```

Except with the above syntax we could have specified any of `ThemeData`'s myriad
other properties to actually make a useable `ThemeData`object.

### 2) TD primarySwatch

We could e.g. have specified a swatch. Let's do that, using both the above blue
and our custom `flexSwatch` and see what that gives us.

```dart
// 2) TD primarySwatch
//    ThemeData(brightness: ..., primarySwatch: Colors.blue)
title: '3) TD primarySwatch',
theme: ThemeData(
  brightness: Brightness.light,
  primarySwatch: Colors.blue,
),
darkTheme: ThemeData(
  brightness: Brightness.dark,
  primarySwatch: Colors.blue,
),
```

If we use the `Colors.blue` as input it will still be identical to 1 and 2.
All using our `flexSwatch` as input will give us, is a variation with a
different color, but let's do it anyway so we can compare it later to its
`ColorScheme` based versions.

```dart
// 2) TD primarySwatch
//    ThemeData(brightness: ..., primarySwatch: flexSwatch)
title: '3) TD primarySwatch',
theme: ThemeData(
  brightness: Brightness.light,
  primarySwatch: flexSwatch,
),
darkTheme: ThemeData(
  brightness: Brightness.dark,
  primarySwatch: flexSwatch,
),
```

### 3) TD colorScheme.fromSwatch

We can also make a `ThemeData` with a `ColorScheme` that is created from
a `MaterialColor` swatch. Let's try this with `Colors.blue` and our
`flexSwatch` as well, and see if we can spot any differences in the result.

```dart
// 3) TD colorScheme.fromSwatch
//    ThemeData(colorScheme: ColorScheme.fromSwatch(...))
//
title: '3) TD colorScheme.fromSwatch',
theme: ThemeData(
  colorScheme: ColorScheme.fromSwatch(
    primarySwatch: Colors.blue // or flexSwatch
    brightness: Brightness.light,
  ),
),
darkTheme: ThemeData(
  colorScheme: ColorScheme.fromSwatch(
    primarySwatch: Colors.blue // or flexSwatch
    brightness: Brightness.dark,
  ),
),
```

### 4) TD colorScheme.fromSwatch

Here is a complex combo, let's use factory `ThemeData.from` a `ColorScheme`
that is created from a `MaterialColor` swatch with `ColorScheme.fromSwatch`.
Let's see this with `Colors.blue` and our `flexSwatch` as well, and see if
we can now spot any differences in the result.

```dart
// 4) TD.from scheme.fromSwatch
//    ThemeData.from(colorScheme: ColorScheme.fromSwatch(...))
//
title: '4) TD.from fromSwatch',
theme: ThemeData.from(
  colorScheme: ColorScheme.fromSwatch(
    primarySwatch: Colors.blue, // or flexSwatch
    brightness: Brightness.light,
  ),
),
darkTheme: ThemeData.from(
  colorScheme: ColorScheme.fromSwatch(
    primarySwatch: Colors.blue, // or flexSwatch
    brightness: Brightness.dark,
  ),
),
```

## Comparing 1 to 4

Let's now compare and analyze the different results.

<table>
  <tr>
    <td><b>1a/b) TD.light </b></td>
    <td>&nbsp;</td>
    <td><b>2) TD primarySwatch</b></td>
    <td>&nbsp;</td>
    <td><b>3) TD fromSwatch</b></td>
    <td>&nbsp;</td>
    <td><b>4) TD.from fromSwatch</b></td>
  </tr>
  <tr>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-01-td-light.png?raw=true" alt="TD Swatch1 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-01-td-light.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-03-td-brightness-light.png?raw=true" alt="TD Swatch2 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-03-td-brightness-light.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-05-td-brightness-light-swatch.png?raw=true" alt="TD Swatch3 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-05-td-brightness-light-swatch.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-07-td-light-fromSwatch.png?raw=true" alt="TD Swatch4 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-07-td-light-fromSwatch.png?raw=true)</td>
  </tr>
    <tr>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-02-td-dark.png?raw=true" alt="TD Swatch1 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-02-td-dark.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-04-td-brightness-dark.png?raw=true" alt="TD Swatch2 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-04-td-brightness-dark.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-06-td-brightness-dark-swatch.png?raw=true" alt="TD Swatch3 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-06-td-brightness-dark-swatch.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-08-td-dark-fromSwatch.png?raw=true" alt="TD Swatch4 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-08-td-dark-fromSwatch.png?raw=true)</td>
  </tr>
  <tr>
    <td colspan="7">_Comparing obsolete ThemeData ColorSWatch based ways to make `ThemeData` objects_</td>
  </tr>
 </table>

 The results above show that options 1, 2 and 3 are all identical. They all also
 share the same problems:

 * ColorScheme colors in light mode all have same blue 500 color.
 * In dark mode we get a default magic teal color, that we did not specify,
   because it is the default. We are going to see this teal color stick around
   a lot in dark themes later too.
 * The dark mode does not look very good, it is grey, not really dark.
 * ColorScheme background in light theme mode color has the wrong contrasting
   onColor. This is bad, and probably a bug, or at least an oversight.
   Why does it get this color?

We can track that from `ThemeData` and see that if we have not passed a `colorScheme`
to it, it will be created with `colorScheme ??= ColorScheme.fromSwatch` and in it
we find this. Cause of issue os explained in the commented Flutter SDK code below.

```dart
// Create a color scheme from a [MaterialColor] swatch.
//
// This constructor is used by [ThemeData] to create its default
// color scheme.
factory ColorScheme.fromSwatch({
  MaterialColor primarySwatch = Colors.blue,
  Color? primaryColorDark,
  Color? accentColor,
  Color? cardColor,
  Color? backgroundColor,
  Color? errorColor,
  Brightness brightness = Brightness.light,
}) {
  assert(primarySwatch != null);
  assert(brightness != null);
  final bool isDark = brightness == Brightness.dark;
  // This is key for the issue, checking if primary needs white or black
  // onColor here is fine for index 500 and the actual primary color:
  final bool primaryIsDark = _brightnessFor(primarySwatch) == Brightness.dark;
  final Color secondary = accentColor ?? (isDark ? Colors.tealAccent[200]! : primarySwatch);
  final bool secondaryIsDark = _brightnessFor(secondary) == Brightness.dark;
  return ColorScheme(
    primary: primarySwatch,
    primaryVariant: primaryColorDark ?? (isDark ? Colors.black : primarySwatch[700]!),
    secondary: secondary,
    secondaryVariant: isDark ? Colors.tealAccent[700]! : primarySwatch[700]!,
    surface: cardColor ?? (isDark ? Colors.grey[800]! : Colors.white),
    // However, here primary swatch 200 is assigned to ColorScheme background.
    background: backgroundColor ?? (isDark ? Colors.grey[700]! : primarySwatch[200]!),
    error: errorColor ?? Colors.red[700]!,
    onPrimary: primaryIsDark ? Colors.white : Colors.black,
    onSecondary: secondaryIsDark ? Colors.white : Colors.black,
    onSurface: isDark ? Colors.white : Colors.black,
    // Here the onBackground gets white or black color, but that does not work
    // because the primaryIsDark boolean is used. That check was for
    // swatch color 500, the swatch color 200 that was used in light mode for
    // background typically does not have the same brightness as the 500 index,
    // so for most swatches we get the wrong contrasting color for onBackground
    // with all these .fromSwatch based ColorScheme creation methods. You would
    // have to know this and correct with a copyWith.
    //
    // Also the swatch does have a lot of nice shades that could be used to
    // set better colors for all the other ColorScheme container colors too
    // but it is chose not too, for backwards compatibility presumably.
    onBackground: primaryIsDark ? Colors.white : Colors.black,
    onError: isDark ? Colors.black : Colors.white,
    brightness: brightness,
  );
}
```

What about the 4th option, in it we are using the recommended way of creating
a `ThemeData`, by using `ThemeData.from` a `ColorScheme`.

This sounds good in theory, but since we are making
the `ColorScheme` using the broken or at least fidelity wise very poor
`ColorScheme.fromSwatch` factory, we will have the same issue with the background's
`onBackground` color in light mode. However, now it gets even funkier.
Since `ThemeData.from` will assign many colors from the `ColorScheme` to
theme colors in `ThemeData`, that are the ones still used on actual surfaces
and background we get "interesting" result. In it `ColorScheme.surface` is
assigned to `ThemeData.cardColor` and both `ThemeData.CanvasColor` and
`scaffoldBackgroundColor` get the `ColorScheme.background`, which is
primarySwatch index 200 shade, it looks a bit like too much color on those
surfaces if you ask me, not even M3 puts this much color on background surfaces.

Let's move on to using `ColorScheme` to make `ColorScheme` based themes as we
should. Then all will be great, right?

## Scheme Based

Making `ThemeData` colors by defining a `ColorScheme` is the recommend way today.
But there are many way to make `ThemeData` with `ColorScheme` as well.
What are their differences? Let's take a look at that. Now we switch from
using the `MaterialColor` swatch as input to the `flexSchemeLight` light and
`flexSchemeDark` dark `ColorScheme` we defined based on the M3 baseline.

### 5) TD colorscheme

Te simplest is to just `ThemeData` with a fully specified `ColorScheme`,
like so:

```dart
// 5) TD colorScheme
//    ThemeData(colorScheme: ColorScheme(...))
//
title: '5) TD colorscheme',
theme: ThemeData(colorScheme: flexSchemeLight),
darkTheme: ThemeData.from(colorScheme: flexSchemeDark),
```

### 6) TD.from colorScheme

Does it matter if we use the `ThemeData.from` a `ColorScheme` factory like so:

```dart
// 6) TD.from colorScheme
//    ThemeData.from(colorScheme: ColorScheme(...))
//
title: '6) TD.from colorScheme',
theme: ThemeData.from(colorScheme: flexSchemeLight),
darkTheme: ThemeData.from(colorScheme: flexSchemeDark),
```

### 7) TD colorSchemeSeed

If we want to make a seeded `ColorScheme`, we can use the `ThemeData` property
`colorSchemeSeed` to do so. Here we are using the `ColorScheme.primary` color
value from the `flexSchemeLight` scheme, as seed color for both the seed
generated light and dart `ColorScheme`. You should use the same seed color
for your light and dark theme, if you want the light and dark `ColorScheme`
to use the identical generated tonal palettes, but with the appropriate tones
for light and dark themes mapped to the generated `ColorScheme.

```dart
// 7) TD colorSchemeSeed
//    ThemeData(colorSchemeSeed: Color(...))
//
title: '7) TD colorSchemeSeed',
theme: ThemeData(
  brightness: Brightness.light,
  colorSchemeSeed: const Color(0xff6750a4),
),
darkTheme: ThemeData(
  brightness: Brightness.dark,
  colorSchemeSeed: const Color(0xff6750a4),
),
```

### 8) TD scheme.fromSeed

Is the above any different from using creating your `ThemeData` using
a `ColorScheme.fromSeed`?

```dart
// 8) TD scheme.fromSeed
//    ThemeData(colorScheme: ColorScheme.fromSeed(...))
//
title: '8) TD scheme.fromSeed',
theme: ThemeData(
  colorScheme: ColorScheme.fromSeed(
    seedColor: const Color(0xff6750a4),
    brightness: Brightness.light,
  ),
),
darkTheme: ThemeData(
  colorScheme: ColorScheme.fromSeed(
    seedColor: const Color(0xff6750a4),
    brightness: Brightness.dark,
  ),
),
```

### 9) TD.from fromSeed

Or what about `ThemeData.from` with a `ColorScheme.fromSeed`, like so:

```dart
// 9) TD.from scheme.fromSeed
//    ThemeData(colorScheme: ColorScheme.fromSeed(...))
//
title: '9) TD.from fromSeed',
theme: ThemeData.from(
  colorScheme: ColorScheme.fromSeed(
    seedColor: const Color(0xff6750a4),
    brightness: Brightness.light,
  ),
),
darkTheme: ThemeData.from(
  colorScheme: ColorScheme.fromSeed(
    seedColor: const Color(0xff6750a4),
    brightness: Brightness.dark,
  ),
),
```

If all these options feel confusing, it is because because they are.
Let's now look at all the results, excluding option 9, we will add to
next group of comparisons.

## Comparing 5 to 8

Lot's of differences here, let's look at them one by one.

<table>
  <tr>
    <td><b>5) TD colorscheme</b></td>
    <td>&nbsp;</td>
    <td><b>6) TD.from colorScheme</b></td>
    <td>&nbsp;</td>
    <td><b>7) TD colorSchemeSeed</b></td>
    <td>&nbsp;</td>
    <td><b>8) TD scheme.fromSeed</b></td>
  </tr>
  <tr>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-09-td-light-colorScheme.png?raw=true" alt="TD Scheme5 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-09-td-light-colorScheme.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-11-td-from-Scheme-light.png?raw=true" alt="TD Scheme6 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-11-td-from-Scheme-light.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-13-td-colorScheme-light.png?raw=true" alt="TD Scheme7 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-13-td-colorScheme-light.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-15-td-ColorScheme-fromSeed-light.png?raw=true" alt="TD Scheme8 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-15-td-ColorScheme-fromSeed-light.png?raw=true)</td>
  </tr>
    <tr>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-10-td-dark-colorScheme.png?raw=true" alt="TD Scheme5 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-10-td-dark-colorScheme.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-12-td-from-Scheme-dark.png?raw=true" alt="TD Scheme6 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-12-td-from-Scheme-dark.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-14-td-colorScheme-dark.png?raw=true" alt="TD Scheme7 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-14-td-colorScheme-dark.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-16-td-ColorScheme-fromSeed-dark.png?raw=true" alt="TD Scheme8 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-16-td-ColorScheme-fromSeed-dark.png?raw=true)</td>
  </tr>
  <tr>
  <td colspan="7">_Comparing of ThemeData ColorScheme options 5 to 8 ways to make `ThemeData` objects_</td>
  </tr>
 </table>


### 5) Analysis - ThemeData made with a ColorScheme

**Option 5** with a `ThemeData` from a full `ColorScheme`, looks as can be expected
we have our `ColorScheme` in the scheme as given. However, none of the scheme
colors have been assigned to any of the direct colors in our `ThemeData`, and since
those colors are still used by a number UI elements it is a bit problematic.

### 6) Analysis - ThemeData.from a ColorScheme

**Option 6** with the `ThemeData.from` using our full `ColorScheme`, things are
as good as they will get in Flutter SDK, when it comes to getting reasonable
colors assigned to legacy colors in `ThemeData`. We can see that in light mode
`primaryColor` got the `ColorScheme.primary` color and `ToggleableColor` got
the ``ColorScheme.secondary` color, not a very nice color in this particular
scheme, but the assignment is correct. We also see that the error color got
copied over to ThemeData. In fact this applies to Canvas, Scaffold, Card
and many other colors too. We can take a look into the `ThemeData.from` factory
to get the full scoop here:

```dart
factory ThemeData.from({
  required ColorScheme colorScheme,
  TextTheme? textTheme,
}) {
  final bool isDark = colorScheme.brightness == Brightness.dark;
  // For surfaces that use primary color in light themes and surface color in dark
  final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
  final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;
  return ThemeData(
    colorScheme: colorScheme,
    brightness: colorScheme.brightness,
    primaryColor: primarySurfaceColor,
    primaryColorBrightness: ThemeData.estimateBrightnessForColor(primarySurfaceColor),
    canvasColor: colorScheme.background,
    accentColor: colorScheme.secondary,
    accentColorBrightness: ThemeData.estimateBrightnessForColor(colorScheme.secondary),
    scaffoldBackgroundColor: colorScheme.background,
    bottomAppBarColor: colorScheme.surface,
    cardColor: colorScheme.surface,
    dividerColor: colorScheme.onSurface.withOpacity(0.12),
    backgroundColor: colorScheme.background,
    dialogBackgroundColor: colorScheme.background,
    indicatorColor: onPrimarySurfaceColor,
    errorColor: colorScheme.error,
    textTheme: textTheme,
    applyElevationOverlayColor: isDark,
  );
}
```

The `accentColor` that `ThemeData.from` still sets is actually deprecated, but
it is still being used in SDK for backwards compatibility reasons. If we look
closely we see that in light theme mode, we get got `colorScheme.secondary` on the
`ThemeData.toggleableActiveColor`, but not in dark mode. Does this matter?

Yes it does, because the `toggleableActiveColor` is still used as default color
by on/off like switches, and in dark theme mode that is now a teal color,
so they will get a teal color that has nothing with our `ColorScheme`, unless
we apply it to it separately. But why did it get the `secondary` color in light
theme mode and not in dark theme mode? After all it is not even assigned any
value in `ThemeData.from`. This happens because `ThemeData` itself does this
thing:

```dart
toggleableActiveColor ??= isDark ? Colors.tealAccent[200]!
                                 : (accentColor ?? primarySwatch[600]!);
```

It is understandable that this logic was kept for all the swatch based
themes backwards compatibility, but why could `ThemeData.from` not just
have also included a line that set:

```dart
toggleableActiveColor: colorScheme.secondary,
```

Along with `accentColor`, back when it was introduced it would have been fine,
and we would have had a slightly less confusing `ThemeData` from a
`ColorScheme` as a result.

Next we have to wonder about three colors that `ThemeData.from` happily ignores
in light theme mode and in dark theme mode make into something completely
different. As can be seen `primaryColorLight`, `primaryColorDark` and
`secondaryHeaderColor` are still the same blue in light theme mode, as when we
used swatch colors. This is because in `ThemeData` they by default get colors
from the swatch, that has not been assigned any value, so it in turn has
defaulted to `Colors.blue`, and we get:

```dart
  primaryColorLight ??= isDark ? Colors.grey[500]! : primarySwatch[100]!;
  primaryColorDark ??= isDark ? Colors.black : primarySwatch[700]!;
  secondaryHeaderColor ??= isDark ? Colors.grey[700]! : primarySwatch[50]!;
```

There are still some UI elements that use these colors as their default colors
in Flutter SDK 2.10, so this means they, like the switches in dark mode, now
use colors that has nothing to do with the `ColorScheme` we wanted our
application to have.

In dark mode we can see that all these colors are grey and even the
`ThemeData.primaryColor` is grey. This might be a bit confusing, since these
colors are not grey in our dark mode `ColorScheme`. Would it not be more
consistent if these colors were different shades of the primary color in dark
mode too? Like they are in light mode, well if you happened to use swatch based
these, which you should not.

Why are they grey? My theory, in earlier version of Flutter's AppBar, the
only way to get the correct dark/grey color on it in dark theme mode, was if this
oddity was added to the factory:

```dart
// For surfaces that use primary color in light themes and surface color in dark
final Color primarySurfaceColor = isDark ? colorScheme.surface : colorScheme.primary;
final Color onPrimarySurfaceColor = isDark ? colorScheme.onSurface : colorScheme.onPrimary;
```

Today this is not needed, at least not for that reason anymore, newer
version of the `AppBar` has this behavior
built-in without depending on `ThemeData.primaryColor`. But it has not been
changed so the colors would make more logical sense in relation the
`ColorScheme`, again due to "legacy" compatibility.

I wrote a long analysis and review about these inconsistences already back in
2020 and then they had already existed for at least year. The curious one can read
about it in [issue 65782](https://github.com/flutter/flutter/issues/65782).
Some of the reported observations in it have since been addressed by the still
on going `ThemeData` redesign work. While some parts, like the
`primaryColorLight` and `primaryColorDark` are not yet even on a deprecation
path, even though all other direct colors in `ThemeData`are, as
mentioned and seen here in [issue 91772](https://github.com/flutter/flutter/issues/91772).

In any case, the road forward is clear and things will get more consistent out
of the box once all the tasks in [issue 91772](https://github.com/flutter/flutter/issues/91772)
are done and have landed in stable channel. As an example `toggleableActiveColor`
has been deprecated, see [PR 95870](https://github.com/flutter/flutter/pull/95870)
channel, there is a migration document prepared
[here](https://docs.flutter.dev/release/breaking-changes/toggleable-active-color#migration-guide.).
This is not yet in stable channel 2.10, but maybe in next stable release already.

Looking forward to the day when the entire `ThemeData` color confusion is cleaned up.
Until then, we will see further below that **FlexColorScheme** can help you with
the inconsistences and give you a coherent color theme now.

On a related note, if you are interested in how the support for Material 3 is
coming along in Flutter, then the umbrella
[issue 91605](https://github.com/flutter/flutter/issues/91605)
is the one to track for that.

### ElevationOverlayColor

One thing the `ThemeData.from` factory has going for it in dark theme mode is
that it correctly uses the ElevationOverlayColor in dark mode by setting,
when the theme brightness is dark:

```dart
applyElevationOverlayColor: true,
```

For dark theme's, this is really something one should do in Material 2 design.
No other `ThemeData` factory turns this on by default, so if you are using them
you should make sure to set it to true for your dark theme.

Material 3 color system uses a new elevation color overlay algorithm that is
not yet available in Flutter 2.10 stable channel, see
[issue 91607](https://github.com/flutter/flutter/issues/91607). In Material 3 an elevation
color overlay is used in both light and dark theme mode. We will return
to looking at it when in lands in stable channel. In this
[PR 100036](https://github.com/flutter/flutter/pull/100036) you can learn and
see what it does. Surfaces get more colored tinted when they are elevated, and you
can do elevation with tint, shadow or both.

When working with elevation overlays in Material 2 it is important to know
that it should be applied to Material surfaces that might get elevated. These
surfaces might actually be using the `ColorScheme.surface` color, which may even
be in the form of `ThemeData.cardColor` on the surface or
`ColorScheme.background`, which again might be in the form of
`ThemeData.canvasColor` this all depends on the actual material surface UI
elements implemented default color, and they vary. However, the surfaces will
only get an elevation overlay color if the color value is equal to
`ColorScheme.surface`, an implementation oversight perhaps.

When you are working with blended surfaces where `surface` and `background`
may differ, this matters. Typically with default Flutter SDK values, these colors
all share the same color value, so the issue won't be noticed. In
**FlexColorScheme** they may be different. FlexColorScheme addresses this issue
by mostly using `ColorScheme.surface` as the themed color, for surfaces that
will typically be elevated, like Card and Dialogs (that default to background).
Additionally if this is not enough, it offers blend modes where surface and
background always get the same blend strength, keeping their color values
identical. You can read more about this design and implementation
oversight here in [issue #90353](https://github.com/flutter/flutter/issues/90353)
that analyzed and suggested a solution that would remedy it.
It is unlikely to ever be addressed, so the best thing to do is to
be aware if it and design around it when so needed for the dark theme design.

### 7 Analysis - ThemeData made with colorSchemeSeed color

This one is surprising when it comes to the outline color. The new
`ColorScheme.outline` color is intended to be used on UI elements having a
design that calls for an outline. This is used e.g. on the new
[Chips design](https://m3.material.io/components/chips/overview), the
[Outlined button](https://m3.material.io/components/buttons/overview) even
[Card](https://m3.material.io/components/cards/overview) comes with a new
outlined option.

However, it is doubtful if this color should be applied directly as is
to the current `ThemeData.dividerColor`. Most likely it should indeed be
this color, but with same or similar opacity as before. Which we get
when we use options 8 and 9. The reason why this demo started looking very weird
with this theme is because the divider color is used for dividers and rail
side separator, and even for what was a very faint border around the color
boxes.

The divider color is not mentioned in the Material 3 guide, yet at least,
but e.g. on the [menu design](https://m3.material.io/components/menus/overview)
we can see a divider. It is not using the outline color directly, as it would be
much stronger. It is perhaps the same color, but with same alpha as before
(0x1F), could be some new opacity value too.
This current divider color is perhaps an oversight with the this theme
creation method.

When it comes to the ThemeData colors, `primaryColor`, `primaryColorLight` and
`primaryColorDark`, plus the `toggleableActiveColor` in dark mode, things are
as poorly supported as mentioned in previous analysis of them.

### 8 Analysis - ThemeData made with a ColorScheme.fromSeed

As with previous case where a ThemeData is made from a `ColorScheme` the
scheme is fine, it is just that we do not get any sensible color assignments
from it on or `ThemeData`, it is the same situation of course, just another
wat to make a `ColorScheme`, a quite fancy way, the color we get in
the `ColorScheme` are quite pretty, although the dull and grey like secondary
color is not so good on switches, but tat is just this particular scheme.


## Flex Based

Next we will compare all the above to what FlexColoScheme produces with same
setup. We can use a fully specified `ColorScheme` as input to `FlexColorScheme`
to create custom themes with it too.

This can be used instead a the `colors` property. The `colors` property is
convenient, since we do not have to
specify all the colors in a `ColorScheme`. FlexColorScheme wil instead handle
the nuances of making one, based on other properties we specify in the
factory, like blends, app bar setup, etc, plus using defaults and computational
colors it will make its own version of a fully specified `ColorScheme` when
it produces its `ThemeData`. Using key colors for the seed generated `ColorScheme`
is another computational `ColorScheme` generation method.

### 10) FTD.light(colorScheme)

In this case we want to use the exact same input `ColorScheme`, so
we can compare the result by using the same input `ColorScheme` again using
the `flexSchemeLight` and `flexSchemeDark` we made like so:

```dart
// 10) FTD.light(colorScheme)
//    FlexThemeData.light(colorScheme:...),
//    FlexThemeData.dark(colorScheme:...),
//
title: '10) FTD.light(colorScheme)',
theme: FlexThemeData.light(colorScheme: flexSchemeLight),
darkTheme: FlexThemeData.dark(colorScheme: flexSchemeDark),
```

In case it was not obvious, earlier above **TD** was used as short for
`ThemeData` to fit on the AppBar and here we use **FTD** as short for
`FlexThemeData`.

### 11) FTD.light(keyColors)

Next, we use the identical seed generated `ColorScheme` as above where we
used `ColorScheme.fromSeed`, by turning on using keyColors, we just pass in
the default setup, which uses the primary color and the same algorithm that
the `ColorScheme.fromSeed` used when we used it with the `primary` color
from our `ColorScheme`.

```dart
// 11) FTD.light(keyColors)
//    FlexThemeData.light(colorScheme:..., keyColors: ...),
//    FlexThemeData.dark(colorScheme:..., keyColors: ...),
//
title: '11) FTD.light(keyColors)',
theme: FlexThemeData.light(
  colorScheme: flexSchemeLight,
  keyColors: const FlexKeyColors(),
),
darkTheme: FlexThemeData.dark(
  colorScheme: flexSchemeDark,
  keyColors: const FlexKeyColors(),
),
```
### 12) FTD.light(key sub)

Lastly we will enable the opinionated component sub-themes, however to not
get stuck on the differences in border radius and shape of the FAB, let's make
it look like Material 2 for this comparison.

Sub-themes also needs a
fontFamily specification when you opt-in on its internal M3 like text theme
with its new geometry, if we want to to hav same Roboto defaults as in
Material 2. The FlexColorScheme's own version of a Material 3 text theme is
temporary, its usage will migrated to using the actual Material 3 TextTheme
and its built in Typography once it lands in stable channel,
see [PR 97829](https://github.com/flutter/flutter/pull/97829).

The new text styles and their names are already available in Flutter 2.10.

```dart
// 12) FTD.light(key sub)
//    FlexThemeData.light(colorScheme:..., keyColors: ...),
//    FlexThemeData.dark(colorScheme:..., keyColors: ...),
//
title: '12) FTD.light(key sub)',
theme: FlexThemeData.light(
  colorScheme: flexSchemeLight,
  keyColors: const FlexKeyColors(),
  subThemesData: const FlexSubThemesData(
    defaultRadius: 4,
    fabUseShape: false,
  ),
  fontFamily: GoogleFonts.roboto().fontFamily,
),
darkTheme: FlexThemeData.dark(
  colorScheme: flexSchemeDark,
  keyColors: const FlexKeyColors(),
  subThemesData: const FlexSubThemesData(
    defaultRadius: 4,
    fabUseShape: false,
  ),
  fontFamily: GoogleFonts.roboto().fontFamily,
),
```

### Compare 9 to 12

Lastly we will compare the Flutter SDK option 9)
ThemeData.from(colorScheme: ColorScheme.fromSeed(...)) method to
the above three `FleXColorScheme` based ones.

<table>
  <tr>
    <td><b>9) TD.from fromSeed</b></td>
    <td>&nbsp;</td>
    <td><b>10) FTD.light(scheme)</b></td>
    <td>&nbsp;</td>
    <td><b>11) FTD.light(key)</b></td>
    <td>&nbsp;</td>
    <td><b>12) FTD.dark(key sub)</b></td>
  </tr>
  <tr>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-17-td-from-ColorScheme-fromSeed-light.png?raw=true" alt="TD Scheme9 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-17-td-from-ColorScheme-fromSeed-light.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-19-flexTD-ColorScheme-light.png?raw=true" alt="TD FlexScheme10 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-19-flexTD-ColorScheme-light.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-21-flexTD-ColorScheme-light-seed.png?raw=true" alt="TD FlexScheme11 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-21-flexTD-ColorScheme-light-seed.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-23-flexTD-ColorScheme-light-seed-sub.png?raw=true" alt="TD FlexScheme12 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-23-flexTD-ColorScheme-light-seed-sub.png?raw=true)</td>
  </tr>
    <tr>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-18-td-from-ColorScheme-fromSeed-dark.png?raw=true" alt="TD Scheme9 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-18-td-from-ColorScheme-fromSeed-dark.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-20-flexTD-ColorScheme-dark.png?raw=true" alt="TD FlexScheme10 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-20-flexTD-ColorScheme-dark.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-22-flexTD-ColorScheme-dark-seed.png?raw=true" alt="TD FlexScheme11 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-22-flexTD-ColorScheme-dark-seed.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-24-flexTD-ColorScheme-dark-seed-sub.png?raw=true" alt="TD FlexScheme12 dark" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-24-flexTD-ColorScheme-dark-seed-sub.png?raw=true)</td>
  </tr>
  <tr>
  <td colspan="7">_Comparing of ThemeData ColorScheme options 9 and FlexColorScheme ways to make similar `ThemeData` objects_</td>
  </tr>
 </table>


**TODO: Review and explain differences**

### Recommendations

**TODO: Add conclusion and recommendations**

### Component Themes

Let's compare the look of some components and the themes impact on them too.

**TODO: Add this chapter for V5**
