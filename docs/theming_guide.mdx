# Theming Guide

This chapter gives an introduction to application theming in Flutter,
it is not so much about using `FlexColorScheme` even if it on occasion
talks about it too. It contains general guidance on Flutter theming
and also explain some choices and usage in FlexColorScheme.

This guide does not talk about how to make beautiful designs, it focus on
the technicalities of how to actually make your `ThemeData`
and make it work for you.

In the [Ways to ThemeData](/theming_ways) chapter we present
different options for producing a `ThemeData` object, show and analyze
what their differences are.

If you are not experienced in theming Flutter applications, then
**FlexColorScheme** can assist you in many ways and often get you quite
close to where you want to be. FlexColorScheme does not address or do
everything that is possible with theming in Flutter, nor will it ever do so.
Its goal is to make commonly used designs quicker and easier to achieve.
To give you a starting point with easy configurable options, that gets you
closer to where you want to be, certainly enough for a PoC or even an MVP.

## Why Theme an App?

You should strive to make the built-in widgets in Flutter
look as close as you can to the look and design you want them to have in your
application, by defining an application theme that brings you as close as
possible. By doing so, you are using Flutter and its theming capabilities to
work for you. and not against you. When you do this most of your
applications design will fall into place almost automagically.

## Custom Widgets

When it comes to custom Widgets you make, you should when possible base their
default styles on properties in the theme as well. Consider what color, font and
other styles it could use as fitting default built-in behavior. Are there
properties in `ThemeData` and its component themes that could be applicable
to your custom widget as defaults? Also provide direct members to configure your
custom widget for those one-off needs, when it needs to be different from
what you set via the `ThemeData` properties as its defaults.

Use the same principle that Flutter's built-in widgets use for their theming
and default style behavior. Basically they do a fall-through from widget
property, to component theme and maybe even ThemeData and its ColorScheme,
and lastly maybe some default behavior.

If you do this, then you are on your way to creating nice reusable widgets,
as well as custom widgets that automatically also follows your
application's theme as you change it.

As an example, say you have a fancy complex composed custom widget, that
contains an icon, among other things. In this design you decided that this
particular icon should have a default color that matches the background
color of a `FloatingActionButton`, but in some case you
may want a custom one-off style. Just do what built-in widgets do, give it
a nullable `Color?` property, e.g. `iconColor` and let it fall through the
same default color behavior that the FAB has, something like this:

```dart
  final ThemeData theme = Theme.of(context);
  final Color effectiveIconColor = iconColor ??
    theme.floatingActionButtonTheme.backgroundColor ??
      theme.colorScheme.secondary;
```

Now you have a color your can use on the icon, that matches that of a
default un-themed FAB, using the `ThemeData.colorScheme.secondary` color
as its default value, but if there was a FAB theme defined, it gets
the background color from it. Additionally you can give it a different custom
color, for those one-off needs.

Obviously as you change your application's `ThemeData`, the FAB and your
custom widget with its matching icon color, will now follow whatever
style that is. If you do the change interactively in your app, it's
default color also lerp animates, since it depends on a theme color.

Don't hard code color and styles for your custom widgets. Don't even default
them to colors, styles and properties that are not derived from the
application's theme, at least not if you want them to change as you modify
the theme of your application.

If your application support different themes that the user can switch between
interactively, including dark mode, then it is important that you use theme
and theme mode aware properties in your custom widgets. If you do so, all
your custom widgets will adjust accordingly when you change the theme, and
their change from one theme mode to another, will even animate correctly.

## More Colors?

With Flutter 2.10.0 and later we have the new Material 3 based `ColorScheme`
that contains much more theme colors than before. Consider first how you
can use those colors in your application and design.
Also look into if you can compute some additional color shades from the colors
in the theme `ColorScheme`, in case none of them are the right shade.

There are many ways to do this with different results, here is a simple way
using white and black colors as overlays in an alpha blend:

```dart
// Using alpha blends is a simple way to make a lighter shade of an existing
// color. Use the source color as background, and overlay it with white and
// vary its alpha to produce a lighter shade of the source color.
final Color lighterPrimary = Color.alphaBlend(
    Colors.white.withAlpha(0x66), Theme.of(context).colorScheme.primary);

// To make a darker shade, do the same but use a black overlay and vary its
// alpha to produce a darker shade of the source color.
final Color darkerPrimary = Color.alphaBlend(
    Colors.dark.withAlpha(0x66), Theme.of(context).colorScheme.primary);
```

Sometimes you might indeed a need a lot of different colors not found in
`ThemeData`, its `Colorscheme` or any of its sub-themes. This is common e.g.
for legends on charts or maps. For those cases using a collection of const
colors that define them and using them globally is often an
acceptable and pragmatic solution.

These are typically not application design colors, they are
more like color attributes that represent certain properties in the real world,
or at least a studied data set of it. Such colors, depend more on how you want
the visualized data to be presented, and not on how the application design
should look. They thus lends themselves well to being outside of the core
application theming.

Of course, if you only need few such colors and are not using all
colors in the `ColorScheme` for your application's design, then nothing really
prevents you from tucking in 3 to 4 color in the `ColorScheme` for this purpose.
If you do so you may need to set colors of some component themes, whose widgets
used those colors. Current this is not big challenge as most components only use
`ColorScheme.primary` or `secondary`.

You can of course in component themes use defined const color values that are
not from you `theme.colorScheme` color set. If you change these colors in your
component theme interactively, their transition will also be nice animated,
since they are still themed color values, but not just via `ColorScheme`.
The Flutter's Material components are however designed to use a coherent
shared `ColorScheme` based design, so if you do this you should verify
that your alternative design looks pleasing too.

**FlexColorScheme** on purpose only allows you select color from the
theme's `ColorScheme` based colors when you customize what colors its opinionated
component themes use. If you make completely custom component themes, you
can use whatever colors you like in them.


## Flutter Defaults?

What colors and TextTheme styles are used by Flutter's widget by default?
This is a good question. Currently they follow the Material 2 design guide
defaults, and will eventually move to follow the Material 3 design guide
defaults. When it comes to default color usage in Material 3, the design
guide does not really yet cover all the details. When widgets start adopting
the Material 3 style when you set `ThemeData.useMaterial3` to true, we will
be able to check in the source what the new defaults are.

As a future update for this guide, I plan to add some cross reference tables
that lists color defaults for different widgets in Material 2, Material 3,
FlexColorScheme with no component themes and with them. Hunting for them
in the Flutter SDK source code is possible, but it is quite tedious.

Another frequent thing I look up in Flutter SDK code is the TextTheme and
which text style is used where by what widget. The only place to find out
is also in the Flutter source code. I might as well add cross reference table
for it as well.

## Custom Themes?

You can make custom inherited themes for your custom widgets as well, you can
even extend Flutter's theme. We won't be going into that in this guide in the
version. In later revisions to this guide I might add some examples of these
possibilities too.

However, if you are interested in it right now, then this
[article](https://www.didierboelens.com/2020/05/material-textstyle-texttheme/)
is very good. It is based on older not null safe version of Dart and Flutter,
but its principles are still the same. This nice article also contains
a cross reference of what TextTheme TextStyle is used as default style by
Flutter Widgets.


## Defining ThemeData

The Flutter `ThemeData` object is a very large theme property data,
and theme behavior controlling class. It can change the look and feel of Flutter
applications completely. It is not really that difficult to use, but it has many
quirks and oddities, especially when it comes to used colors. This is mostly
due to past legacy and things that were not considered early on. Some parts were
done differently first, later things changed, but those earlier ways are
still supported in order not to break past behavior. THen when you newer ways to
define and setup colors, it all becomes a bit confusing, especially since official
docs and theming guides often still use the older ways that do not produce as
nicely colored and color consistent themes.

When you make themed Flutter applications you should base the colors of your
application on a light theme mode suitable `ColorScheme`, and a dark theme mode
suitable `ColorScheme`. Then create your light and dark `ThemeData` using these color
schemes, by assigning the `ColorScheme` for each mode to the `colorScheme`
property in `ThemeData`. In your `MaterialApp` you then assign the `ThemeData`
for your light, and dark theme to the `theme` and `darkTheme` properties
in the `MaterialApp`.

```dart
void main() => runApp(const DemoApp());

class DemoApp extends StatelessWidget {
  const DemoApp({Key? key}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Custom ThemeData',
      theme: ThemeData.from(colorScheme: mySchemeLight),
      darkTheme: ThemeData.from(colorScheme: mySchemeLight),
      themeMode: ThemeMode.system,
      home: HomePage(),
    );
  }
}
```

In theory this gives you an application that uses the defined color schemes on
all the Flutter SDK built-in Material UI widgets. Well, it almost does and it
should. It almost does so, especially if you used Flutter's `ThemeData.from`
a `ColorScheme`, like above. But even it has a few gaps. The used color scheme
is not consistently applied on all built-in Flutter SDK Material UI Widgets.

To get it really right, you still also have to assign a few colors from your
`ColorScheme` to a number of color properties that still exist as direct color
properties in `ThemeData`.

This is all further complicated by the fact that under the hood many Flutter
SDK UI widgets still use the original direct color properties in
`ThemeData`. These properties are now mostly assigned color
values via `ThemeData.colorScheme`. Exactly how depends on which
`ThemeData` factory constructor you use.

Many older components still do not use the `ThemeData.colorScheme` properties for
their default color values directly, they still use color property values from
`ThemeData`, that got assigned values from `ThemeData.colorScheme`, that varies
depending on used `ThemeData` creation factory! Still with me?

Very basic and old widgets, like for example `Material` and `Card` fall into
this category. While some newer widgets actually do use colors
from `ThemeData.colorScheme` directly. Additionally, the colors in the
`ColorScheme` held by the `colorScheme` property in `ThemeData` can actually not
represent all the colors that exist in `ThemeData`'s color properties. Thus, some
of those color properties never get any `ColorScheme` based values assigned to
them. They are left to default values assigned by the `ThemeData` factory,
unless you explicitly assign them some color that fits with your color scheme.
If this is not done, it can then look odd when some widgets use the factory
default colors, while the rest of your app's widgets correctly use the
`ColorScheme` based colors. Luckily there are not so many widgets left that this
still applies to, but there are a few, for example `CircleAvatar`.

It can all be very confusing and frustrating to fight with ThemeData and its
colors, and if not done properly, it may result in themes with color schemes
that are not entirely consistent or logical across all standard SDK
widgets in your application.

In the chapter [Ways to ThemeData](/theming_ways) we will look at pretty much
all the different ways to define a `ThemeData` object. We will see
different result like these, depending on how we do it.

<table>
  <tr>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-03-td-brightness-light-flex.png?raw=true" alt="TD flex Swatch2 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-03-td-brightness-light-flex.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-05-td-brightness-light-swatch-flex.png?raw=true" alt="TD flex Swatch3 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-05-td-brightness-light-swatch-flex.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-07-td-light-fromSwatch-flex.png?raw=true" alt="TD flex Swatch4 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-07-td-light-fromSwatch-flex.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-09-td-light-colorScheme.png?raw=true" alt="TD Scheme5 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-09-td-light-colorScheme.png?raw=true)</td>
  </tr>
  <tr>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-11-td-from-Scheme-light.png?raw=true" alt="TD Scheme6 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-11-td-from-Scheme-light.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-13-td-colorScheme-light.png?raw=true" alt="TD Scheme7 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-13-td-colorScheme-light.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-15-td-ColorScheme-fromSeed-light.png?raw=true" alt="TD Scheme8 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-15-td-ColorScheme-fromSeed-light.png?raw=true)</td>
    <td>&nbsp;</td>
    <td>[<img src="https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-17-td-from-ColorScheme-fromSeed-light.png?raw=true" alt="TD Scheme9 light" width="220"/>](https://github.com/rydmike/flex_color_scheme_docs/blob/master/docs/images/fcs-v5-wt-17-td-from-ColorScheme-fromSeed-light.png?raw=true)</td>
  </tr>
  <tr>
    <td colspan="7">_Many different ways to make `ThemeData` using same `ColorScheme` or same seed color_</td>
  </tr>
 </table>


## Deprecation Road-map

There is a Flutter development plan in progress to **deprecate all** of
the direct color properties in the `ThemeData` class. Flutter SDK widgets
should after that only use `ColorScheme` based colors that are in the
ThemeData `colorScheme` property, as default colors for their designs.

This design [document](https://flutter.dev/go/material-theme-system-updates)
describes the plan and reasoning. There is also a color property deprecation
check list [issue 91772](https://github.com/flutter/flutter/issues/91772) to
mirror this plan. It has taken a while, but there is a lot of activity and
progress being made on this now in the Flutter master channel.

For **FlexColorScheme** the progress of these actions are monitored
closely. Needed changes and updates in FlexColorScheme will be implemented when
relevant changes in `ThemeData` reach the Flutter stable channel.
FlexColorScheme already of course correctly defines a `ColorScheme` for
`ThemeData`. The typical maintenance need is removing deprecated
`ThemeData` properties and check if some new sub-theme color property needs
to be modified to replicate past **FlexColorScheme** theming behavior, when
its corresponding color property is removed from `ThemeData`.


## ThemeMode

In some older apps and theming guides you might find, they use setups where
the light and dark themes are both assigned to `theme` using a conditional
operator depending desired `Brightness`.

Don't do this, it was something that was used way back,
before there was a `darkTheme` property in the `MaterialApp`. Instead do
assign your theme mode appropriate themes to the correct properties in
the `MaterialApp`. This also applies to `highContrastTheme` and
`highContrastDarkTheme` theme. If your app has special designs for high
contrast accessibility themes, do assign them to these properties.
These properties are all there to give you the right device system
settings driven behavior. So it can follow system theme mode and accessibility
settings.

If your app does not offer a way to toggle theme mode via the `themeMode`
property, then keep `themeMode` at its default `ThemeMode.system`, so that
the app theme automatically follows the device theme mode. If you do offer a
way to override and set the app to light or dark theme independently of the
the system, personally I recommend this. Then always
also include in the selections to use the system mode that follow the system
setting, this should even be your starting default value for it. Now you
covered all options and users can set the mode as they prefer.


## FlexColorScheme ThemeData

At its core, `FlexColorScheme.toTheme` creates a `ThemeData` object. It helps
you make a color scheme based, consistent and a more refined
Flutter `ThemeData` object.

One of the fundamental things FlexColorScheme does, is that it fixes minor
inconsistencies and gaps that exist with Flutter's `ThemeData.from` factory
and handles the complexity of using the `ThemeData` factory directly. It
releases you from the burden of knowing what colors in it affects which widgets
how.

FlexColorScheme makes a few opinionated, but subtle theme modifications compared
to the `ThemeData.from` themes created from a `ColorScheme`. By default,
FlexColorScheme theming refrains from touching theme properties not related
to making the colors more consistent. Some minor adjustments were however
needed. This is covered in detail in the API guide section in
[Core defaults](/core_defaults).
