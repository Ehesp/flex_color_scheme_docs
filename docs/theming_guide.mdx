# Theming Guide

**TODO: Complete this chapter for version 5, it is sill WIP, but progressing!**

**TODO: Add some images as examples to make it more interesting**

The purpose of this chapter is to provide an introduction to application theming in
Flutter. Present different options and show what their differences are.
This chapter will contain general guidance on Flutter theming and also explain
some choices and usage in FlexColorScheme. This guide will not talk about how
to make beautiful design, but rather focus on how to actually make your
ThemeData and make it work for you.

If you are not experienced in theming Flutter applications, then FlexColorScheme
can assist you in many ways and often get you quite close to where you
want to be. FlexColorScheme does not address or do everything that is possible
with theming in Flutter, nor will it ever do so. Its goal is however to make
commonly used designs quicker and easier to achieve, to give you a starting
point with easy configurable options, that gets you closer to where you want
to be, certainly often enough for a PoC or even an MVP.

## Why Theme?

You should always strive to make the built-in widgets in Flutter
look as close as you can to the look and design you want to have in your
application, by defining an application theme that brings you as close as
possible. By doing so, you are using Flutter and its theming capabilities to
work for you and not against you, and most of your applications design will
fall into place almost automagically.

When it comes to custom Widgets you make, you should when possible base their
default styles on properties in the theme as well. Consider what color, font and
other styles it could use as fitting default built-in behavior. Are there
properties in `ThemeData` and its component themes that could be applicable
to your custom widget as defaults? Also provide direct members to configure your
custom widget for those one-off needs when it needs to be different from
what you set via the `ThemeData` properties as its defaults.

Use the same principle that Flutter's built-in widget use for their theming
and default style behavior. Basically they do a fall-through from widget
property, to component theme and maybe even ThemeData and its ColorScheme,
and lastly maybe even some default behavior, if nothing from any theme fit.

If you do this, then you are on your way to creating nice reusable widgets,
as well as custom widgets that automatically also follows your
application's theme as you change it.

As an example, say you have a fancy complex composed custom widget, that
contains an icon, among other things. In this design you decided that this
particular icon should have a default color that matches the background
color of a `FloatingActionButton`, but in some case you
may want a custom one off style. Just do what built-in widgets do, give it
a nullable `Color?` property, e.g. `iconColor` and let it fall through the
same default color behavior that the FAB has, something like this:

```dart
  final ThemeData theme = Theme.of(context);
  final Color effectiveIconColor = iconColor ??
    theme.floatingActionButtonTheme.backgroundColor ??
      theme.colorScheme.secondary;
```

Now you have a color your can use on the icon, that matches that of a
default un-themed FAB, using the `ThemeData.colorScheme.secondary` color
as its default value, but if there was a FAB theme defined, it gets
its background color from it, and you can give it a
different color, for those one-off needs should that ever occur, if you do,
then it uses the given constructor color.

Obviously as you change your application's `ThemeData`, the FAB and and
your custom widget with its matching icon color, will now follow whatever
style that is. If you do the change interactively in your app, it's
default color also lerp animates, since it depends on a theme color.

Don't hard code color and styles for your custom widgets. Don't even default
them to colors, styles and properties that are not derived from the
application theme, at least not if you want them to change as you modify
the theme of your application.

If your application support different themes that the user can switch between
interactively, including dark mode, then it is critical that you use theme
and theme mode aware properties in your custom widgets. If you do so, all
your custom widgets will adjust accordingly when you change the theme, and
their change from one theme mode to another will even animate correctly.

## More Colors?

With Flutter 2.10.0 and later we have the new Material 3 based `ColorScheme`
that contains much more theme colors than before. Consider first how you
can use those colors in your application and design.
Also look into if you can compute some additional color shades from the colors
in the theme `ColorScheme`, in case none of them are the right shade.

Sometimes you might indeed a need a lot of different colors not found in
`ThemeData`, its `Colorscheme` or any of its sub-themes. This is common e.g.
for legends on charts or maps. For those cases using a collection of const
colors that define them and using them globally is certainly in my opinion
an acceptable option.

Why so I think so? These are typically not application design colors, they are
more like color attributes that represent certain properties in the real
world or the studied data set. Such colors, depend more on how you want the
visualized data to be presented, and not on how the application design should
look. They thus lends themselves well to being outside of the application
theming.

Of course if you only need few such colors and are not using all
colors in the `ColorScheme` for your application's design, then nothing really
prevents you from tucking in 3..4 color in the `ColorScheme` for this purpose.
If you do so you may need to set colors of some component themes that used
those colors. Current this is not big challenge as most components only use
either `ColorScheme` `primary` or `secondary`.

## Flutter Defaults?

What colors and TextTheme styles are used by Flutter's widget by default?
This is a good question. Currently they follow the Material 2 design guide
defaults, and will eventually move to follow the Material 3 design guide
defaults. When it comes to default color usage in Material 3, the design
guide does not really yet cover all the details. When widgets start adopting
the Material 3 style when you set `ThemeData.useMAterial3` to true, we will
be able to check in the source what the defaults are.

As a future update for this guide, I plan to add some cross reference tables
that lists color defaults for different widgets in Material 2, Material 3,
FlexColorScheme with no component themes and with them. Hunting for them
in the Flutter SDK source code is possible, but it is quite tedious.

Another frequent thing I look up in Flutter SDK code is the TextTheme and
which text style is used where by what widget. The only place to find out
is also in the Flutter source code. I might as well add cross reference table
for it as well.

## Custom Themes?

You can make custom inherited themes for your custom widgets as well, you can
even extend Flutter's theme. We won't be going into that quite yet in this guide.
In later revisions to this guide I might add some examples of these
possibilities too.

However, if you are interested in it right now, then this
[article](https://www.didierboelens.com/2020/05/material-textstyle-texttheme/)
is very good. It is based on older not null safe version of Dart and Flutter,
but its principles are still the same. This nice article also contains
a cross reference of what TextTheme TextStyle is used as default style by
Flutter Widgets.


## Defining ThemeData

The Flutter `ThemeData` object is a very large theme property data,
and theme behavior controlling class. It can change the look and feel of Flutter
applications completely. It is not really that difficult to use, but it has many
quirks and oddities, especially when it comes to used colors. This is mostly
due to past legacy and things that were not considered early on. Some parts were
done differently first, later things changed, but those earlier ways are
still supported in order not to break past behavior. THen when you newer ways to
define and setup colors, it all becomes a bit confusing, especially since official
docs and theming guides often still use the older ways that do not produce as
nicely colored and color consistent themes.

When you make themed Flutter applications you should base the colors of your
application on a light theme mode suitable `ColorScheme`, and a dark theme mode
suitable `ColorScheme`. Then create your light and dark `ThemeData` using these color
schemes, by assigning the `ColorScheme` for each mode to the `colorScheme`
property in `ThemeData`. In your `MaterialApp` you then assign the `ThemeData`
for your light, and dark theme to the `theme` and `darkTheme` properties
in the `MaterialApp`.

In theory this gives you an application that uses the defined color schemes on
all the Flutter SDK built-in Material UI widgets. Well, it almost does and it
should. It almost does if you used Flutter's `ThemeData.from` a `ColorScheme`.
But even it has a few gaps. The used color scheme is not consistently
applied on all built-in Flutter SDK Material UI Widgets.

To get it really right, you still also have to assign a few colors from your
`ColorScheme` to a number of color properties that still exist as direct
properties in `ThemeData`.

This is all further complicated by the fact that
under the hood many Flutter SDK UI widgets still use the original direct color
properties in `ThemeData`. These properties are now mostly assigned color
values via `ThemeData.colorScheme`. Exactly how depends on which
`ThemeData` factory constructor you use.

Many older widgets still do not use the `ThemeData.colorScheme` properties for
their default color values directly, they still use color property values from
`ThemeData`, that got assigned values from `ThemeData.colorScheme`, that varies
depending on used `ThemeData` factory! Still with me?

Very basic and old widgets, like for example `Material` and `Card` fall into
this category. While some newer widgets actually do use colors
from `ThemeData.colorScheme` directly. Additionally, the colors in the
`ColorScheme` held by the `colorScheme` property in `ThemeData` can actually not
represent all the colors that exist in `ThemeData`'s color properties. Thus, some
of those color properties never get any `ColorScheme` based values assigned to
them. They are left to default values assigned by the `ThemeData` factory,
unless you explicitly assign them some color that fits with your color scheme.
If this is not done, it can then look odd when some widgets use the factory
default colors, while the rest of your app's widgets correctly use the
`ColorScheme` based colors. Luckily there are not so many widgets left that this
still applies to, but there are a few, for example `CircleAvatar`.

It can all be very confusing and frustrating to fight with ThemeData and its
colors, and if not done properly, it may result in themes with color schemes
that are not entirely consistent or logical across all standard SDK
widgets in your application.

There is a Flutter development plan in progress to **deprecate all** of
the direct color properties in the `ThemeData` class. Flutter SDK widgets
should after that only use `ColorScheme` based colors that are in the
ThemeData `colorScheme` property, as default colors for their designs.

This design [document](https://flutter.dev/go/material-theme-system-updates)
describes the plan and reasoning. There is also a color property deprecation
check list [issue 91772](https://github.com/flutter/flutter/issues/91772) to
mirror this plan. It has taken a while, but there is a lot of activity and
progress being made on this now in the Flutter master channel.

For **FlexColorScheme** the progress of these actions are monitored
closely. Needed changes and updates in FlexColorScheme will be implemented when
relevant changes in `ThemeData` reach the Flutter stable channel.
FlexColorScheme already of course correctly defines a `ColorScheme` for
`ThemeData`. The typical maintenance need is removing deprecated
`ThemeData` properties and check if some new sub-theme color property needs
to be modified to replicate past **FlexColorScheme** theming behavior, when
its corresponding color property is removed from `ThemeData`.


## ThemeMode

In some older apps and theming guides you might find, they use setups where
the light and dark themes are both assigned to `theme` using a conditional
operator depending desired `Brightness`.

Don't do this, it was something that was used way back,
before there was a `darkTheme` property in the `MaterialApp`. Instead do
assign your theme mode appropriate themes to the correct properties in
the `MaterialApp`. This also applies to `highContrastTheme` and
`highContrastDarkTheme` theme. If your app has special designs for high
contrast accessibility themes, do assign them to these properties.
These properties are all there to give you the right device system
settings driven behavior. So it can follow system theme mode and accessibility
settings.

If your app does not offer a way to toggle theme mode via the `themeMode`
property, then keep `themeMode` at its default `ThemeMode.system`, so that
the app theme automatically follows the device theme mode. If you do offer a
way to override and set the app to light or dark theme independently of the
the system, personally I recommend this. Then always
also include in the selections to use the system mode that follow the system
setting, this should even be your starting default value for it. Now you
covered all options and users can set the mode as they prefer.


## FlexColorScheme ThemeData

At its core, `FlexColorScheme.toTheme` creates a `ThemeData` object. It helps
you make a color scheme based, consistent and a more refined
Flutter `ThemeData` object.

One of the fundamental things FlexColorScheme does, is that it fixes minor
inconsistencies and gaps that exist with Flutter's `ThemeData.from` factory
and handles the complexity of using the `ThemeData` factory directly. It
releases you from the burden of knowing what colors in it affects which widgets
how.

FlexColorScheme makes a few opinionated, but subtle theme modifications compared
to the `ThemeData.from` themes created from a `ColorScheme`. By default,
FlexColorScheme theming refrains from touching theme properties not related
to making the colors more consistent. Some minor adjustments were however
needed. This is covered in detail in the API guide section in
[Core defaults](/core_defaults).


**TODO: The part below need review plus update or be scrapped for V5**


## Color Blended Surfaces

The Material 2 Guide briefly mentions
[color branded and blended surfaces](https://material.io/design/color/dark-theme.html#properties).
In the new version of Material Design called [Material You and now also known as
Material 3](https://m3.material.io/), color branded or blended and also
just colored surfaces, are used extensively. It is done in more flexible ways
than what can be done with theming alone in current version of Flutter. We look
forward to seeing these features soon in Flutter as well.

With **FlexColorScheme** you can already with current version of Flutter SDK
easily create fancy looking primary color branded
and alpha blended themes. These themes work natively with the current Material
2 design based themes and all UI widgets in the current version of Flutter.

The themes are created by using different blend modes and blend level strengths,
for blending in primary color into surface and background colors. This can bring
different and new nuances to your application. Below an example of the
same theme, but using different blend modes and levels. The effect can be kept
very subtle or made very bold and impactful.

The first light and dark image pair show the theme using blend level 0.
At level 0 there are no alpha blends of primary color in any surfaces, so all
modes look the same. The next six images use the same blend level strength 18,
but show six different blend modes. Next, one of the modes is repeated,
but at blend level 33. Last the theme that was used to generate all these
different nuances of the same color scheme based theme, is shown.

[<img src="https://rydmike.com/assets_fcsv4/06-blend-examples.jpg?raw=true" alt="blend examples"/>](
https://rydmike.com/assets_fcsv4/06-blend-examples.png?raw=true)
_FlexColorScheme using same theme, but with
different blend modes and levels (click image to open hires version)_

There are **9 different blend modes at 40 different levels each**, that you can
choose from, to tune a theme to your liking. You don't have to use the
same blend mode or level for your light and dark theme mode, the included
examples only do so to keep the interactive examples simpler. Often a
different blend mode and level for your light and dark themes, may produce
a more balanced or more impactful result, depending on your design goal.

The above images were made with the **Themes Playground** (example 5) app
running as a phone app, instead of using the
[web demo](https://rydmike.com/flexcolorschemeV4Tut5).
The application is open source, and is included as the last example in the
pub.dev bundled examples and on
[GitHub here](https://github.com/rydmike/flex_color_scheme/tree/master/example/lib/example5).
The **Themes Playground** is an interesting and useful tool when you want to
find fitting themes, blend modes and levels to use as your application's
FlexColorScheme based theme. It even allows you to copy/paste the code needed
to make the Flutter theme you are looking at.
